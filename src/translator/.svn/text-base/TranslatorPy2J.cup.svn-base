package translator;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.lang.*;
import symbol.*;
import models.*;
import util.*;
init with {:
	
	symTable=new SymbolTable();
	arraySymbolTable=new ArrayList<SymbolTable>();
	InherSupport = new Hashtable<String,String>();
	StaticSupport = new Hashtable<String,String>();
	Constructors = new Hashtable<String,String>();
	globVar = new ArrayList<String>();
	arrayMain =new ArrayList<String>();
	scopeHash = new Hashtable<String, Integer>();
	writeClass=new WriteClassToFile();
	ignore = new ArrayList<String>();
	ereditClassToFunctionInvocation = new ArrayList<String>();
:};


parser code
{:
	//Tabella dei simboli -> parser.getSymbolTable()
	public static SymbolTable symTable;
	public static ArrayList<SymbolTable> arraySymbolTable;
	
	//Stack da usare per l'indentazione
	Hashtable<String, Integer> scopeHash;
	
	//Array per mantenere la lista delle classi ereditate e da usare in caso di metodi invocati
	ArrayList<String> ereditClassToFunctionInvocation;
	
	//Struttura di supporto per il corpo dei metodi in caso di gestione di ereditarietà
	public Hashtable<String,String> InherSupport;
	public Hashtable<String,String> StaticSupport;
	public Hashtable<String,String> Constructors;
	public ArrayList<String> ignore;
	
	//oggetto utilizzato per scrivere ciascuna classe su file
	public static WriteClassToFile writeClass;
	
	/*
	  Struttura di supporto per le variabili globali: la strategia implementativa consiste nell'inserirle
	  all'interno di una classe statica richiamata per accedere alle stesse, pertanto esse devono essere 
	  raccolte all'interno di un array che verra' utilizzato (nell'apposito metodo) per generare tale classe.
	  
	*/
	ArrayList<String> arrayMain;
	ArrayList<String> globVar;

	// ridefinisco la funzione per la gestione degli errori
    public void report_error(String message, Object info) {
        //System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                //System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
   
    
    // funzione che mi restituisce il simbolo attuale
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }
    
    // ritorna la regola semantica associata ad un simbolo in una certa posizione (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }
    
    // restituisce il numero della riga in cui si trova il simbolo corrente
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    
    // restituisce il numero della colonna in cui si trova il simbolo corrente
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    public SymbolTable getSymbolTable(){
		return symTable;
	}
    
    public Hashtable<String,Integer> getScopeHash(){
		return scopeHash;
	}
    
		
:}

action code
{:

		/*
		*
		***********************************  GESTIONE EREDITARIETA' MULTIPLA **********************
		*
		*/

	 
		private String mergeClasses(ArrayList<String> classes, String mark){
			String newCl="";
			ArrayList<Hashtable<String, ArrayList<SymbolType>>> m = new ArrayList<Hashtable<String, ArrayList<SymbolType>>>(); 
			for(int i=0;i<classes.size();i++){
					m.add(getClass(classes.get(i)));
					getEntity(m.get(i),classes.get(i));
			}			
			//System.out.println("TO MERGE: "+m.toString());
			for(int i=0;i<classes.size();i++){
				newCl+=classes.get(i);
			}
			return merge(classes.size(),m,mark);
		}		
		
		public String merge(int dim,ArrayList<Hashtable<String, ArrayList<SymbolType>>> toMerge,String mark){
			String str ="";
			String par="";
			String constructor="";
			ArrayList<SymbolType> name = new ArrayList<SymbolType>();
			ArrayList<SymbolType> attributes = new ArrayList<SymbolType>();
			ArrayList<SymbolType> methods = new ArrayList<SymbolType>();
			ArrayList<String> params = new ArrayList<String>();
			ArrayList<SymbolType> constr = new ArrayList<SymbolType>();
			
			//RECUPERO IL NOME DELLA NUOVA CLASSE DA ESTENDERE..
			String newClass="";
			for(int i=0;i<dim;i++){
				newClass = newClass+toMerge.get(i).get("class").get(0).getName();
				if(!toMerge.get(i).get("constructor").isEmpty())
					constr.add(toMerge.get(i).get("constructor").get(0));
				else
					constr.add(new SymbolType(toMerge.get(i).get("class").get(0).getName(),"constructor","",new ArrayList<String>(),"",1,toMerge.get(i).get("class").get(0).getName()));
			}
			parser.symTable.putSymbol(0,newClass,new SymbolType(newClass,"class",null,null,null,0,newClass));
			str = "public class "+newClass+"{\n";
						
			//RECUPERO GLI ATTRIBUTI ASSOCIATI ALLE CLASSI..
			for(int i=0;i<toMerge.size();i++){
				for(int j=0;j<toMerge.get(i).get("attr").size();j++){
					//String currAttr = toMerge.get(i).get("attr").get(j).getOwner()+"_"+toMerge.get(i).get("attr").get(j).getName();
					String currAttr = toMerge.get(i).get("attr").get(j).getName();
					String currType = toMerge.get(i).get("attr").get(j).getType();
					String currValue = toMerge.get(i).get("attr").get(j).getValue();
					//String currOwner = toMerge.get(i).get("attr").get(j).getOwner();
					String currOwner = mark;
					
					if(parser.symTable.checkEntity(currAttr+"#"+currOwner)){
						//System.out.println("ATTRIBUTE DUPLICATE!");
					}else{
						if(currType.equals("Tupla")){
							currValue = currValue.replace("\"","\\\"");
							//System.out.println("FOUND TUPLA WITH PARAMETERS: "+currValue);
							//System.out.println("I PUT: \n"+currAttr+"#"+currOwner+"\n"+currType+"\n"+currValue+"\n"+currOwner+"\n");
							parser.symTable.putSymbol(1,currAttr+"#"+currOwner,new SymbolType(currAttr,currType,currValue,null,null,1,currOwner));
							str = str+"Object"+" "+currAttr+"= new Tupla(\""+currValue+"\");\n";
						}
						else if(currType.equals("GenericList")){
							currValue = currValue.replace("\"","\\\"");
							//System.out.println("FOUND GENERIC LIST WITH PARAMETERS: "+currValue);
							//System.out.println("I PUT: \n"+currAttr+"#"+currOwner+"\n"+currType+"\n"+currValue+"\n"+currOwner+"\n");
							parser.symTable.putSymbol(1,currAttr+"#"+currOwner,new SymbolType(currAttr,currType,currValue,null,null,1,currOwner));
							str = str+"Object"+" "+currAttr+"= new GenericList(\""+currValue+"\");\n";
						}
						else if(currType.equals("PDictionary")){
							currValue = currValue.replace("\"","\\\"");
							//System.out.println("FOUND PDICTIONARY WITH PARAMETERS: "+currValue);
							//System.out.println("I PUT: \n"+currAttr+"#"+currOwner+"\n"+currType+"\n"+currValue+"\n"+currOwner+"\n");
							parser.symTable.putSymbol(1,currAttr+"#"+currOwner,new SymbolType(currAttr,currType,currValue,null,null,1,currOwner));
							str = str+"Object"+" "+currAttr+"= new PDictionary(\""+currValue+"\");\n";
						}
					else{
					//System.out.println("I PUT: \n"+currAttr+"#"+currOwner+"\n"+currType+"\n"+currValue+"\n"+currOwner+"\n");
					parser.symTable.putSymbol(1,currAttr+"#"+currOwner,new SymbolType(currAttr,currType,currValue,null,null,1,currOwner));
					str = str+"Object"+" "+currAttr+"="+currValue+";\n";
					}
					}				
				}
			}
			
			//GENERO IL COSTRUTTORE DELLA CLASSE UNIONE RISULTANTE..
			String p = getConstructors(constr);
			String bod = mergeBod(constr);
			if(!bod.equals("")){
				constructor += "public "+newClass+"("+getConstructors(constr)+"){\n"+mergeBod(constr)+"\n}\n";
				//System.out.println("GENERATE CONSTRUCTOR: "+constructor);
				//Lo assegno alla stringa principale..
				str+=constructor;
			}else{
				constructor += "//Costruttore di default\n public "+newClass+"(){}\n";
				//System.out.println("GENERATE CONSTRUCTOR: "+constructor);
				//Lo assegno alla stringa principale..
				str+=constructor;
			}
						
			//RECUPERO I METODI ASSOCIATI ALLE CLASSI..
			for(int i=0;i<toMerge.size();i++){
				for(int j=0;j<toMerge.get(i).get("meth").size();j++){
					//System.out.println("NOW WORKING WITH: "+toMerge.get(i).get("meth").toString());
					if(toMerge.get(i).get("meth").get(j).getParameters()!=null){
						String currMeth=toMerge.get(i).get("meth").get(j).getName();
						ArrayList<String> currParams = toMerge.get(i).get("meth").get(j).getParameters();
						String currReturn = toMerge.get(i).get("meth").get(j).getReturned();
						String currOwner = mark;
						String nparam=String.valueOf(currParams.size());
						if(parser.symTable.checkEquivalentMethods(currMeth+"#"+nparam+"#"+currOwner)){
							//System.out.println("FOUND EQUIVALENT METHODS!");
						}else{
						//System.out.println("I PUT: \n"+currMeth+"#"+nparam+"#"+currOwner+"\nTYPE: Function\n"+currParams+"\n"+currReturn+"\n"+currOwner+"\n");
						parser.symTable.putSymbol(1,currMeth+"#"+nparam+"#"+currOwner,new SymbolType(currMeth,"function",null,currParams,currReturn,1,currOwner));
						String body = parser.InherSupport.get(toMerge.get(i).get("meth").get(j).getName());				
						str = str+UtilsToSymTable.getFunctionModifier(toMerge.get(i).get("meth").get(j).getName())+toMerge.get(i).get("meth").get(j).getReturned()+" "+toMerge.get(i).get("meth").get(j).getName()+"("+getParams(toMerge.get(i).get("meth").get(j).getParameters())+"){\n"+body+"\n}\n";
						}
					}else{
						String currMeth=toMerge.get(i).get("meth").get(j).getName();
						String currReturn=toMerge.get(i).get("meth").get(j).getReturned();
						String currOwner= mark;
						String nparam=String.valueOf(0);
						if(parser.symTable.checkEquivalentMethods(currMeth+"#"+nparam+"#"+currOwner)){
							//System.out.println("FOUND EQUIVALENT METHODS!");
						}else{
						//System.out.println("I PUT (NO PARAMS): \n"+currMeth+"#"+nparam+"#"+currOwner+"\n"+currReturn+"\n"+currOwner+"\n");
						parser.symTable.putSymbol(1,currMeth+"#"+nparam+"#"+currOwner,new SymbolType(currMeth,"function",null,new ArrayList<String>(),currReturn,1,currOwner));
						String body = parser.InherSupport.get(toMerge.get(i).get("meth").get(j).getName());
						str = str+UtilsToSymTable.getFunctionModifier(toMerge.get(i).get("meth").get(j).getName())+toMerge.get(i).get("meth").get(j).getReturned()+" "+toMerge.get(i).get("meth").get(j).getName()+"(){}\n";
						}
						}
				}
			}
			//Chiudo la classe..
			str = str+"}\n";
			return str;	
			}
		
		
		/**
		 * Restituisce la lista di parametri (Sotto forma di stringa) da inserire nel costruttore unione..
		 * **/
		public String getConstructors(ArrayList<SymbolType> constr){
				if(constr.isEmpty()) return "";
				String par="";
				ArrayList<String> tmp = new ArrayList<String>();
				for(int i=0;i<constr.size();i++){
					for(int j=0;j<constr.get(i).getParameters().size();j++){
						boolean b=false;
						for(int k=0;k<tmp.size();k++){
							if(tmp.get(k).equals(constr.get(i).getParameters().get(j))) b=true;
						}
						if(!b){
							tmp.add(constr.get(i).getParameters().get(j));
							par+=constr.get(i).getParameters().get(j)+",";
						}else{
							//System.out.println("Parameter "+constr.get(i).getParameters().get(j)+ "Ignored!");
							parser.ignore.add(constr.get(i).getName());
						}
					}
				}
				return par.substring(0, par.length()-1);
		}
		
		/***
		 * Restituisce il corpo del nuovo costruttore frutto del merge dei precedenti..
		 * 
		 * */
		
		public String mergeBod(ArrayList<SymbolType> constr){
			if(constr.isEmpty()) return "";
			String body="";
			//System.out.println("TO IGNORE: "+parser.ignore.toString());
			if(parser.ignore.isEmpty()){
				for(int i=0;i<constr.size();i++){
					body +=constr.get(i).getValue();
				}
				return body;
			}
			else{
				body = "";
				semanticAlert("Ignoring body: Semantic Error");
				return body;
			}
		}
		
		
		
		public boolean checkEquivalentMethods(String currMeth,ArrayList<String> met){
			if(met.isEmpty()){
				 	//System.out.println("EQUIVALENT NOT FOUND!");
					return false;
			}
			for(int i=0;i<met.size();i++){
				//System.out.println("CHECK EQUIVALENT FOR: "+currMeth+"\n WITH: "+met.get(i));
					if(met.get(i).equals(currMeth)){
					 	//System.out.println("FOUND EQUIVALENT!");
					 	return true;
				}
			}
			//System.out.println("EQUIVALENT NOT FOUND!");
			return false;
		}
			
		public String getParams(ArrayList<String> parameters){
			String par="";
			if(!parameters.isEmpty()){
				for(int k=0;k<parameters.size()-1;k++){
					if(k==0){
						par=par+parameters.get(k).substring(2,parameters.get(k).length())+", ";
					}else
						par=par+parameters.get(k)+", ";
				}
				par=par+parameters.get(parameters.size()-1);
				return par;
			}return par;
		}
		
		public Hashtable<String, ArrayList<SymbolType>> getClass(String classes){
		 	Hashtable<String, ArrayList<SymbolType>> toMerge = new Hashtable<String, ArrayList<SymbolType>>();
			ArrayList<SymbolType> cl = new ArrayList<SymbolType>(); 
			Hashtable<String, SymbolType> a = parser.symTable.getSymTable(0);
			Enumeration e = a.keys();
			while(e.hasMoreElements()){
				String key = (String)e.nextElement();
				if(a.get(key).getType().equals("class") && a.get(key).getName().equals(classes)){
					//System.out.println("Class found:\n"+a.get(key));
					//Recupero attributi e metodi associati a questa classe.
					cl.add(a.get(key));
					toMerge.put("class",cl);
					//Inizializzo gli array per la classe trovata..
					toMerge.put("attr", new ArrayList<SymbolType>());
					toMerge.put("meth", new ArrayList<SymbolType>());
					toMerge.put("constructor", new ArrayList<SymbolType>());
				}
			}
			return toMerge;
		}
		
		public void getEntity(Hashtable<String, ArrayList<SymbolType>> toMerge,String currClass){			
			for(int i=1;i<parser.symTable.getSize();i++){
				Hashtable<String, SymbolType> a = parser.symTable.getSymTable(i);
				Enumeration eps = a.keys();
				while(eps.hasMoreElements()){
					String key = (String)eps.nextElement();
					//System.out.println("CURRENT KEY: "+key);
					if(a.get(key).getOwner().equals(currClass) && a.get(key).getType().equals("function")){
							//System.out.println("Entity found (FUNCTION):\n"+a.get(key));
							toMerge.get("meth").add(a.get(key));
					}
					else if(a.get(key).getOwner().equals(currClass) && a.get(key).getType().matches("String|Object|Integer|Float|GenericList|PDictionary|Tupla|Double")){
						//System.out.println("Entity found (ATTR):\n"+a.get(key));
						if(checkduplicated(a.get(key),toMerge.get("attr")))
							toMerge.get("attr").add(a.get(key));
						else System.out.println("#Error: Attr duplicated!"); 
					}
					else if(a.get(key).getOwner().equals(currClass) && a.get(key).getType().equals("constructor")){
						//System.out.println("Entity found (CONSTR):\n"+a.get(key));
						toMerge.get("constructor").add(a.get(key));
					}
				}
			}
		}

		
		public String getStaticMeth(){
			if(parser.StaticSupport.isEmpty()) return "";
			String meths="";
			Enumeration e = parser.StaticSupport.keys();
			while(e.hasMoreElements()){
				String key = (String)e.nextElement();
				//System.out.println("StaticSupport: "+key);
				SymbolType st = parser.symTable.getSymbol(0,key);
				//UtilsToSymTable.printArrayList(st.getParameters(),"st.getParameters()");
				StringBuilder sb = new StringBuilder();
				for(int i=0;i<st.getParameters().size();i++){
					sb.append(st.getParameters().get(i));
					if(i!=st.getParameters().size()-1)
						sb.append(",");
				}
				String currBody = parser.StaticSupport.get(key);
				String returned = parser.symTable.getSymbol(0,key).getReturned();
				meths+="public static "+returned+" "+key.split("#")[0]+"("+sb.toString()+"){\n"+currBody+"\n}\n";
			}
			//System.out.println("STATIC METHODS FOUND: "+meths+"\n CLOSED!");
			return meths;
		}
		
		public String getStaticVar(){
			if(parser.globVar.isEmpty() && parser.StaticSupport.isEmpty() && parser.arrayMain.isEmpty()) return "";
			//System.out.println("START STATIC CLASS");
			String stClass = "public class DefaultClass {\n";
			
			//variabili globali
			for(int i=0;i<parser.globVar.size();i++){
				stClass +="public static Object "+parser.globVar.get(i)+";\n";
			}
			
			//main
			stClass += "public static void main(String args[]){\n";
			for(int j=0;j<parser.arrayMain.size();j++)
				stClass +=parser.arrayMain.get(j)+"\n";
			stClass +="}\n";
			
			//altre funzioni
			stClass += getStaticMeth();
			
			//fine DefaulClass
			stClass +="}\n";
			parser.writeClass.writeFile2(stClass,"DefaultClass");
			System.out.println(stClass+"\n\n");
			return stClass;
		}
		
		public boolean checkduplicated(SymbolType currAttr,ArrayList<SymbolType> attr){
			for(int i=0;i<attr.size();i++){
				if(currAttr.getName().equals(attr.get(i).getName())){
						return false;
				}
			}
			return true;
		}		
		
		//NON UTILIZZATO..
		public ArrayList<Hashtable<String, ArrayList<SymbolType>>> init(int dim){
			ArrayList<Hashtable<String, ArrayList<SymbolType>>> m = new ArrayList<Hashtable<String, ArrayList<SymbolType>>>();
			for(int i=0;i<dim;i++){
				m.add(new Hashtable<String, ArrayList<SymbolType>>());
			}
			return m;
		}
		
		
		/**
		 * UTILITY METHODS
		 * 
		 * **/
		
		public String checkPar(ArrayList<String> argv, int scope, String className){
			String pas="";
			boolean ret = false;
			if(argv.isEmpty()){
				//System.out.println("No params found!");
				return "";
			}
			ArrayList<String> argz = UtilsToSymTable.tokenParameters(argv.get(0), ",");
			//System.out.println("I HAVE TO CHECK: "+argz.toString());
			if(!argz.isEmpty()){
				for(int i=0;i<argz.size();i++){
					//System.out.println("I ANALYZE SYMBOL: "+argz.get(i)+" IN SCOPE: "+scope+" FOR CLASS: "+className);
					if(argz.get(i).equals("self")){
						//System.out.println("REMOVING SELF!");
						argz.remove(i);
					}
					else if(parser.symTable.getSymbol(scope,argz.get(i))!=null){
						ret = true;
					}
					else ret=true;
				}
				//System.out.println("CHECK RESULT: "+ret+ " FOR ARGS: "+argz.toString());
				//if(ret){
					for(int j=0;j<argz.size();j++)
						pas += argz.get(j)+",";
					return pas.substring(0,pas.length()-1);
			//	}
					
			//	else 
				//	return "";
			}
			return pas;
		}
		
		/*
		*
		***********************************  GESTIONE ERRORI SEMANTICI/SINTATTICI ********************
		*
		*/
		
		
		private void semanticAlert(String message){
        		System.err.println("SEM WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
    	}
    	
    	private void semanticError(String message){
    			System.err.println("SEM ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
    	}
    	
    	
    	/*
		*
		***********************************  GESTIONE INDENTAZIONE ***********************************
		*
		*/
    	
    	
    	private int getIndentation()
    	{
    		return ((TranslatorPy2JLex)parser.getScanner()).stackLength()-1;
    	}
    	
    	
    	/*
		*
		***********************************  GESTIONE ASSEGNAZIONE *********************************
		*
		*/
    	
    	
    	public StringBuilder getTypeOfAssignator(String element){
    	
    		StringBuilder sb = new StringBuilder();
    		
    		boolean flag = true;
    		
    		//TODO: RIVEDERE IL DISCORSO RICERCA ATTRIBUTI SYMBOL TABLE
    		if(UtilsToSymTable.tokenParameters(element,".").size()>1){
    			//es: istanzaOggetto.attributo -->splitto rispetto al punto
    			
    			//se ad esempio ho: p.attr
    			//singleElement.get(0) = p
    			//singleElement.get(1) = attr
    			ArrayList<String> singleElement = UtilsToSymTable.tokenParameters(element,".");
				
				String className = UtilsToSymTable.getVariableType(singleElement.get(0),getIndentation(), parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
				if(className!=null){
					boolean flag_attr = UtilsToSymTable.isCorrectClassAttributeUsed(singleElement.get(1),className,getIndentation(), parser.getSymbolTable());
					if(flag_attr==true)
						sb.append("OBJECT-ASSIGNMENT"+"#"+singleElement.get(0)+"#"+singleElement.get(1)+"#"+className);
					else
						sb.append("ERROR");
				}else{
					sb.append("ERROR");
				}
				

    		}else if(UtilsToSymTable.tokenParameters(element,",").size()>1){
				//es: x,y,z = t (con t tupla di dimensione 3)
				
				//System.out.println("TUPLA-UNPACKING");
				sb.append("TUPLA-UNPACKING");
				ArrayList<String> singleElement = UtilsToSymTable.tokenParameters(element,",");
				
				for(int i = 0; i<singleElement.size(); i++){
					if(CheckType.check(singleElement.get(i)).equals("Object")){
						sb.append("#"+singleElement.get(i));
					}else{
						flag=false;
					}
				}
				
			}else if(UtilsToSymTable.tokenParameters(element,"[]").size()>1){
				//es: d['key'] = 34.78 -> con d dizionario
				
				//System.out.println("DICTIONARY-ASSIGNAMENT");
				sb.append("DICTIONARY-ASSIGNAMENT");
				ArrayList<String> singleElement = UtilsToSymTable.tokenParameters(element,"[]");
				sb.append("#"+singleElement.get(0));  //es: d
				sb.append("#"+singleElement.get(1));  //es: 'key'
				
			}else{
				//non abbiamo nulla di certo
				//System.out.println("NOTHING-CERTAIN");
				sb.append("NOTHING-CERTAIN");
				
			}
			
			if(flag==true)
    			return sb;
    		else
    			return null;
    	
    	}
    	
    	
    	public StringBuilder getStringBuilderAssignament(String type, String parameterDX, String parameterSX, int level){
    		
    		StringBuilder sb = new StringBuilder();
    		
    		//System.out.println("getStringBuilderAssignament: " + parameterSX);
    		//System.out.println("getStringBuilderAssignament: " + parameterDX);
    		
    		boolean flag = UtilsToSymTable.isExist(parameterSX.replace("self.",""),level, parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
    		
    		//Object c = 3;
    		
    		if(flag==false){
    			sb.append("Object ");
    		}
    		sb.append(parameterSX);
    		sb.append(" = ");
    		
    		if(type.equals("Tupla")){
    			
    			ArrayList<String> whithoutVirgola = UtilsToSymTable.tokenParameters(parameterDX, "(,)");
    			//UtilsToSymTable.printArrayList(whithoutVirgola, "whithoutVirgola - perTupla");
    			StringBuilder sb2 = new StringBuilder();
    			for(int y=0; y<whithoutVirgola.size();y++){
    				String type_2 = CheckType.check(whithoutVirgola.get(y));
    				if(type_2.equals("Object")){
    					sb2.append(UtilsToSymTable.getStringBuilderToCast(whithoutVirgola.get(y),level,parser.getSymbolTable(), parser.ereditClassToFunctionInvocation));
    				}else{
    					String newParameterDX = whithoutVirgola.get(y).replace("\"","\\\"");
    					//String newParameterDX = whithoutVirgola.get(y).replace("\"","");
    					sb2.append("\""+ newParameterDX +"\"");
    				}
    				if(y!=whithoutVirgola.size()-1){
    					sb2.append(" + \",\" + ");
    				}	
    			}
    			
    			//System.out.println("sb2: " + sb2.toString());
    			
    			//String newParameterDX = parameterDX.replace("\"","\\\"");
    			//sb.append("new Tupla(\""+newParameterDX+"\")");
    			sb.append("new Tupla("+sb2.toString()+")");
    			sb.append(";\n");
    		}else if(type.equals("GenericList")){
    			
    			ArrayList<String> whithoutVirgola = UtilsToSymTable.tokenParameters(parameterDX, "[,]");
    			//UtilsToSymTable.printArrayList(whithoutVirgola, "whithoutVirgola - perGenericList");
    			StringBuilder sb2 = new StringBuilder();
    			for(int y=0; y<whithoutVirgola.size();y++){
    				String type_2 = CheckType.check(whithoutVirgola.get(y));
    				if(type_2.equals("Object")){
    					sb2.append(UtilsToSymTable.getStringBuilderToCast(whithoutVirgola.get(y),level,parser.getSymbolTable(), parser.ereditClassToFunctionInvocation));
    				}else{
    					String newParameterDX = whithoutVirgola.get(y).replace("\"","\\\"");
    					//String newParameterDX = whithoutVirgola.get(y).replace("\"","");
    					sb2.append("\""+ newParameterDX +"\"");
    				}
    				if(y!=whithoutVirgola.size()-1){
    					sb2.append(" + \",\" + ");
    				}	
    			}
    			
    			//System.out.println("sb2: " + sb2.toString());
    			
    			//String newParameterDX = parameterDX.replace("\"","\\\"");
    			//sb.append("new GenericList(\""+newParameterDX+"\")");
    			sb.append("new GenericList("+sb2.toString()+")");
    			sb.append(";\n");
    		}else if(type.equals("PDictionary")){
    			
    			ArrayList<String> whithoutVirgola = UtilsToSymTable.tokenParameters(parameterDX, "{,}");
    			//UtilsToSymTable.printArrayList(whithoutVirgola, "whithoutVirgola - perDICT");
    			StringBuilder sb2 = new StringBuilder();
    			for(int y=0; y<whithoutVirgola.size();y++){
    				ArrayList<String> whithoutTwoPoints = UtilsToSymTable.tokenParameters(whithoutVirgola.get(y), ":");
    				//UtilsToSymTable.printArrayList(whithoutTwoPoints, "whithoutTwoPoints - perDICT");
    				for(int t=0;t<whithoutTwoPoints.size();t++){
    					String type_2 = CheckType.check(whithoutTwoPoints.get(t));
        				if(type_2.equals("Object")){
        					sb2.append(UtilsToSymTable.getStringBuilderToCast(whithoutTwoPoints.get(t),level,parser.getSymbolTable(), parser.ereditClassToFunctionInvocation));
        				}else{
        					String newParameterDX = whithoutTwoPoints.get(t).replace("\"","\\\"");
        					//String newParameterDX = whithoutVirgola.get(t).replace("\"","");
        					sb2.append("\""+ newParameterDX +"\"");
        				}
        				if(t!=whithoutTwoPoints.size()-1)
        					sb2.append("+\":\"+");
    				}
    				
    				if(y!=whithoutVirgola.size()-1){
    					sb2.append("+\",\"+");
    				}
    				
    			}
    			
    			//System.out.println("sb2: " + sb2.toString());
    			
    			//String newParameterDX = parameterDX.replace("\"","\\\"");
    			//sb.append("new PDictionary(\""+newParameterDX+"\")");
    			sb.append("new PDictionary("+sb2.toString()+")");
    			sb.append(";\n");
    		}else{
    			sb.append(parameterDX);
    			sb.append(";\n");
    		}
    		
    		return sb;
    		
    	
    	}
    	
    	
    	public StringBuilder getStringBuilderSubTuplaOrGenericList(String type, String parameterDX, String parameterSX, String arg, int level){
    		
    		boolean flag = UtilsToSymTable.isExist(parameterSX.replace("self.",""),level, parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
    		StringBuilder sb = new StringBuilder();
    		
    		if(flag==false){
    			sb.append("Object ");
    			sb.append(parameterSX);
    			sb.append(" = new ");
    			sb.append(type);
    			sb.append("();\n");
    		}
    		
    		sb.append(parameterSX);
    		sb.append(" = ");
    		
    		if(type.equals("Tupla")){
    			sb.append("((Tupla)" + parameterDX +").subTupla(\""+arg+"\");\n");
    		}else if(type.equals("GenericList")){
    			sb.append("((GenericList)" + parameterDX +").subGenericList(\""+arg+"\");\n");
    		}
    		return sb;
    	
    	}
    	
    	
    	
    	public StringBuilder getStringBuilderResultOperationTuplaOrGenericList(String type, String parameterSX, String arg, int level){
    		
    		boolean flag = UtilsToSymTable.isExist(parameterSX.replace("self.",""),level, parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
    		StringBuilder sb = new StringBuilder();
    		
    		if(flag==false){
    			sb.append("Object ");
    			sb.append(parameterSX);
    			sb.append(" = new ");
    			sb.append(type);
    			sb.append("();\n");
    		}
    		
    		if(type.equals("Tupla")){
    			sb.append("((Tupla)" + parameterSX +").resultOperationsTupla(\""+arg+"\");\n");
    		}else if(type.equals("GenericList")){
    			sb.append("((GenericList)" + parameterSX +").resultOperationsGenericList(\""+arg+"\");\n");
    		}
    		return sb;
    	
    	}
    	
    	
    	public String formatString(String strToFormat){
			String newSTR = strToFormat.replace("\"","\\\"");
			String STRwithQuotes = "\""+newSTR+"\"";
			return STRwithQuotes;
    	}
    	
    	public ArrayList<String> getOperator(ArrayList<String> arrayLP,String lastParameters){
	    	
    		//**** GESTIONE OPERATORI ****
											
			StringBuilder operator = new StringBuilder();
			
			for(int l=0;l<arrayLP.size();l++){
				if(l!=arrayLP.size()-1)
					operator.append(arrayLP.get(l)+"|") ;
				else
					operator.append(arrayLP.get(l)) ;
			}
	
			ArrayList<String> arrayOperator=new ArrayList<String>();
			arrayOperator=UtilsToSymTable.tokenParameters(lastParameters,operator.toString());
			
    		return arrayOperator;
    	}
    	
    	
    	
    	public String getDXAssignament(String type, String lastParameter){
    		StringBuilder sb = new StringBuilder();
    		if(type.equals("Tupla")){
    			sb.append(" = new Tupla(\""+lastParameter+"\");\n");
    		}else if(type.equals("GenericList")){
    			sb.append(" = new GenericList(\""+lastParameter+"\");\n");
    		}else if(type.equals("PDictionary")){
    			sb.append(" = new PDictionary(\""+lastParameter+"\");\n");
    		}else {
    			sb.append(" = "+lastParameter+";\n");
    		}
    		return sb.toString();
    	}


		/*
		*
		***********************************  GESTIONE ASSEGNAZIONE PARTE 2  ******************************
		*
		*/


		public ArrayList<String> managerStringWithPoint(String firstPoint, String afterPoint, int level){
			//casi:
			//1) istanza.funzione
			//2) istanza.attributo
			//3) Classe.funzione
			//4) Classe.attributo
			//5) funzione() ???????????
			
			ArrayList<String> informations = new ArrayList<String>();
			
			String manager = "OK";
			
			//se afterPont ha parentesi () -> si tratta di invocazione metodo
			//se NON ha parente () -> si tratta di uso di un attributo di una qualche classe
			
			if(afterPoint.contains("(") && afterPoint.contains(")")){
			
				// SI FUNZIONE - NO ATTRIBUTO
			
				//arrayWithoutParents.get(0) = nomeFunction
				//arrayWithoutParents.get(1) = lista argomenti -> ma potrebbe non esistere (se non passo alcun argomento)
				ArrayList<String> arrayWithoutParents = UtilsToSymTable.tokenParameters(afterPoint,"()");
				
				/**
				 * typeOfFunctionUsed = 1 -> caso: funzione()
				 * typeOfFunctionUsed = 2 -> caso: NomeClasse.funzione()
				 * typeOfFunctionUsed = 3 -> caso: istanza.funzione()
				 */
				String typeOfFunctionUsed = "0";
				
				int numFunctionParam = 0;
				String parameterList = "";
				if(arrayWithoutParents.size()>1){
					ArrayList<String> params = UtilsToSymTable.tokenParameters(arrayWithoutParents.get(1),",");
					numFunctionParam = params.size();
					parameterList = arrayWithoutParents.get(1);
				}
				
				String className = new String();
				String functionName = new String();
				
				if(firstPoint == null){
					//caso: v = funzione()
					className = "DefaultClass";
					functionName = arrayWithoutParents.get(0);
					typeOfFunctionUsed = "1";
				}else{
					//vedo se firstPoin è una classe o una istanza:
					boolean isClass = UtilsToSymTable.isExistClass(firstPoint, level, parser.getSymbolTable());
					if(isClass){
						//caso: v = NomeClasse.funzione()
						className = firstPoint;
						functionName = firstPoint + "_" + arrayWithoutParents.get(0);
						typeOfFunctionUsed = "2";
					}else{
						//caso: v = istanza.funzione()
						boolean isAVariable = UtilsToSymTable.isExist(firstPoint,getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
						if(isAVariable){
							className = UtilsToSymTable.getVariableType(firstPoint,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							functionName = arrayWithoutParents.get(0);
							typeOfFunctionUsed = "3";
						}else{
							//L'istanza non e' stata precedentemente dichiarata! ERROR!
							manager = "ERROR - Variable/Istance Not Declared";
						}
					}
				}
			
				String functionNameToSearch = functionName + "#" + String.valueOf(numFunctionParam) + "#" + className;
				
				//System.out.println("functionNameToSearch: " +functionNameToSearch);

				boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(functionName,String.valueOf(numFunctionParam),className, getIndentation(),parser.getSymbolTable());
				
				if(funcOK && UtilsToSymTable.functionHasReturn(functionName,String.valueOf(numFunctionParam),className, getIndentation(), parser.getSymbolTable())){
					//System.out.println("funcOK____functionNameToSearch: TRUE");
					
					informations.add("FUNCTION-INVOCATION");
					informations.add(typeOfFunctionUsed);
					informations.add(functionName);
					informations.add(String.valueOf(numFunctionParam));
					informations.add(className);
					informations.add(parameterList);
					informations.add(firstPoint);
					
				}else{
					manager = "ERROR - Method Dont Exist";
				}
				
				
				
			}else{
				
				// NO FUNZIONE - SI ATTRIBUTO
				
				/**
				 * typeOfAttributeUsed = 1 -> caso: NomeClasse.attr
				 * typeOfAttributeUsed = 2 -> caso: istanza.attr
				 */
				String typeOfAttributeUsed = "0";
				
				String className = new String();
				String attributeName = new String();
				if(firstPoint!=null){
					boolean isClass = UtilsToSymTable.isExistClass(firstPoint, level, parser.getSymbolTable());
					if(isClass){
						//caso: v = NomeClasse.attr
						className = firstPoint;
						attributeName = firstPoint + "_" + afterPoint;
						typeOfAttributeUsed = "1";
					}else{
						//caso: v = istanza.attr
						boolean isAVariable = UtilsToSymTable.isExist(firstPoint,getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
						if(isAVariable){
							className = UtilsToSymTable.getVariableType(firstPoint,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							attributeName = firstPoint + "." + afterPoint;
							typeOfAttributeUsed = "2";
						}else{
							//L'istanza non è stata precedentemente dichiarata! ERROR!
							manager = "ERROR - Variable/Istance Not Declared";
						}
					}
					
					String attributeNameToSearch = attributeName + "#" + className;					
					boolean attrOK = UtilsToSymTable.isExist(attributeNameToSearch, getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
					
					if(attrOK){
						//System.out.println("attrOK____attributeNameToSearch: TRUE");
						
						informations.add("ATTRIBUTE-USED");
						informations.add(typeOfAttributeUsed);
						informations.add(firstPoint);
						informations.add(afterPoint);
						informations.add(className);
						informations.add(firstPoint);
						
					}else{
						manager = "ERROR - Attribute Dont Exist";
					}
				}
			}
			
			return informations;
		}

		public String getStringBuilderForStringWithPoint(String firstPoint, String afterPoint, int level){
			
			ArrayList<String> informations = managerStringWithPoint(firstPoint, afterPoint, level);
			
			if(informations.size()!=0){
				
				if(informations.get(0).equals("FUNCTION-INVOCATION")){
					//caso con funzione
					if(informations.get(1).equals("1")){
						//caso: v = funzione()  -> DefaultClass.funzione(...)
						return "DefaultClass."+informations.get(2)+"("+informations.get(5)+")";
					}
					if(informations.get(1).equals("2")){
						//caso: v = NomeClasse.funzione() -> NomeClasse_funzione(...)
						return informations.get(4)+"_"+informations.get(2)+"("+informations.get(5)+")";
					}
					if(informations.get(1).equals("3")){
						//caso: v = istanza.funzione() -> ((NomeClasse)istanza).funzione(...)
						return "(("+informations.get(4)+")"+informations.get(6)+")."+informations.get(2)+"("+informations.get(5)+")";
					}
					
				}else{
					//caso con attributo
					if(informations.get(1).equals("1")){
						//caso: v = NomeClasse.attr
						return informations.get(4)+"_"+informations.get(2);
					}
					if(informations.get(1).equals("2")){
						//caso: v = istanza.attr
						return "(("+informations.get(4)+")"+informations.get(2)+")."+informations.get(3);
					}
				}
			}
			
			return null;
		}
		
		
		public String getTypeForStringWithPoint(String firstPoint, String afterPoint, int level){
			
			ArrayList<String> informations = managerStringWithPoint(firstPoint, afterPoint, level);
			
			if(informations.size()!=0){
				
				if(informations.get(0).equals("ATTRIBUTE-USED")){
					//caso con attributo
					if(informations.get(1).equals("1")){
						//caso: v = NomeClasse.attr
					}
					if(informations.get(1).equals("2")){
						//caso: v = istanza.attr
						String name = informations.get(2) + "." + informations.get(3) + "#" + informations.get(4);
						return UtilsToSymTable.getVariableType(name, level,parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
					}
				}
			}
			
			return null;
		}
		
		
		
		public String getLEN(String argoment, int level, String type){
			String lenArgumentType = new String();
			if(type==null)
				lenArgumentType = CheckType.check(argoment);
			else
				lenArgumentType = type;

			//System.out.println("TYPE getLEN: " +lenArgumentType);
			
			if(lenArgumentType.equals("Tupla")){
				//((Tupla)argoment.)getSize()
				return "((Tupla)"+argoment+").getSize()";
			}
			if(lenArgumentType.equals("GenericList")){
				return "((GenericList)"+argoment+").getSize()";
			}
			if(lenArgumentType.equals("PDictionary")){
				return "((PDictionary)"+argoment+").getSize()";
			}
			if(lenArgumentType.equals("String")){

				if(argoment.contains("\"") || argoment.contains("\'")){
					//sicuro Stringa
					return "((String)"+argoment+").length()";
				}else{
					//potrebbe esere p.attr o p.func()
					ArrayList<String> arrayWithouthPoint = UtilsToSymTable.tokenParameters(argoment, ".");
					if(arrayWithouthPoint.size()>1){
						ArrayList<String> informations = managerStringWithPoint(arrayWithouthPoint.get(0), arrayWithouthPoint.get(1), level);
						if(informations.size()!=0){
							String innerFunctionSet = getStringBuilderForStringWithPoint(arrayWithouthPoint.get(0), arrayWithouthPoint.get(1), level);
							if(informations.get(0).equals("FUNCTION-INVOCATION")){
								//le funzioni le tratto come STRINGHE perchè non so il tipo di ritorno
								return "((String)"+innerFunctionSet+".toString()"+").length()";
							}else{
								//caso p.attr
								String type_pAttr = getTypeForStringWithPoint(arrayWithouthPoint.get(0), arrayWithouthPoint.get(1), level);
								if(type_pAttr!=null){
									if(lenArgumentType.equals("Tupla")){
										return "((Tupla)"+innerFunctionSet+").getSize()";
									}
									if(lenArgumentType.equals("GenericList")){
										return "((GenericList)"+innerFunctionSet+").getSize()";
									}
									if(lenArgumentType.equals("PDictionary")){
										return "((PDictionary)"+innerFunctionSet+").getSize()";
									}
									if(lenArgumentType.equals("String")){
										return "((String)"+innerFunctionSet+").length()";
									}
								}
							}
						}
					}
					//System.out.println(" QUI ");
				}
			}
			if(lenArgumentType.equals("Object")){
				String objectType = UtilsToSymTable.getVariableType(argoment,level,parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
				String result = getLEN(argoment, level, objectType);
				//System.out.println("RESULT RICORSIONE: " + result) ;
				return result;
			}
			return null;
		}
		

		public String isLEN(String allString, int level){


			ArrayList<String> arrayWithouthParents = UtilsToSymTable.tokenParameters(allString.replace("self.",""), "()");
			//UtilsToSymTable.printArrayList(arrayWithouthParents, "isLEN - arrayWithouthParents: ");
			
			//verifico il nome della funzione
			if(arrayWithouthParents.get(0).equals("len") && arrayWithouthParents.size()>1){
				return getLEN(arrayWithouthParents.get(1), level, null);
			}//fine if(len)
			else if(arrayWithouthParents.get(0).equals("range") && arrayWithouthParents.size()>1){
				//TODO
				return null;
			}//fine if(len)
			
			
			return null;
		}

		
:}



terminal        AND, AS, ASSERT, BREAK, CLASS, CONTINUE;
terminal        DEF, DEL, ELIF, ELSE, EXCEPT, EXEC, COMMENT, WHITESPACE;
terminal        FINALLY, FOR, FROM, GLOBAL, IF, IMPORT;
terminal        IN, IS, LAMBDA, NOT, OR, PASS,YIELD, TRIDOT, DIVDIV,NEWLINE, MULTMULT, INDENT, DEDENT;
terminal        PRINT, RAISE, RETURN, TRY, WHILE, WITH, RANGE;
terminal		PLUS, MINUS, MULT, DIVIDE, MOD, EXPON, DOT, MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ;
terminal		COMMA,SEMI,ASSIGN,COLON,LBRACK,RBRACK,LCURLY,RCURLY,LPAREN,RPAREN,TILDE,ECOM,PIPE,LSHIFT,RSHIFT;
terminal		AT,PLUSEQ,MINUSEQ,MULTEQ,DIVEQ,MODEQ,ANDEQ,OREQ,EXPEQ,RSEQ,LSEQ;
terminal		DECIMAL, LONGINT, HEX, OCT, BIN,FLOAT,IMAGNUM;
terminal 		String NAME, STRING;

non terminal	prog, prog_manager , stmt,simple_stmt, expr_stmt, print_stmt,del_stmt,flow_stmt,import_stmt, assert_stmt,global_stmt,exec_stmt;
non terminal	number, binop, unop, comparison, lambdef, expr, atom, test, trailer, yield_expr, testlist_comp, listmaker, dictorsetmaker, testlist, exprlist;
non terminal	list_iter, list_for, list_if, varargslist, positional_arguments, single_parameter, fpdef, fplist, name_recoursive, range_stmt;
non terminal	augassign, assign_recoursive, return_stmt,raise_stmt, dotted_name, dotted_as_name, dotted_as_names, import_as_name, import_as_names, dot_rec;
non terminal	arglist, subscriptlist, subscript,subscript_rec,sliceop,argument,argument_rec,comp_for,comp_iter,comp_if, compound_stmt;
non terminal	if_stmt, while_stmt, for_stmt, try_stmt, with_stmt, funcdef, classdef, decorated, suite, stmt_rec, small_stmt, small_stmt_kleine, comment;
non terminal	else_recoursive,except_clause, except_clause_recoursive, with_item, with_item_recoursive, decorator, decorators, parameters;


precedence left LAMBDA;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ, IN, IS;
precedence left PIPE;
precedence left EXPON;
precedence left ECOM;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence left TILDE;
precedence right MULTMULT;


start with prog;

/* Da qui in poi ci vanno le produzioni */

prog ::= prog_manager:p
			{: 
				//Creo la classe statica associata alle eventuali variabili globali
				String globVariables = getStaticVar();
				
				System.out.println("\n###############################\n");
				System.out.println(p.toString());
				System.out.println("\n###############################\n");
				
				RESULT = p.toString();
			:}
;

prog_manager ::= NEWLINE prog_manager:p {: RESULT = "\n"+p.toString(); :}
			| stmt:s prog_manager:p {: RESULT = s.toString() + p.toString(); :}
			| {: RESULT = ""; :}
;

//**********************implementazione del pattern decorator********************************
decorator		::= AT dotted_name NEWLINE
					| AT dotted_name LPAREN RPAREN NEWLINE
					| AT dotted_name LPAREN arglist RPAREN NEWLINE
;
					
decorators		::= decorator 
					| decorators decorator 
;
decorated		::= decorators classdef 
					| decorators funcdef
;
//*******************************************************************************************

// Gestione def della funzione -> suite = contiene il corpo della funzione (NEWLINE, INDENTATION, ISTRUZIONI)
funcdef		::= DEF NAME:n parameters:p COLON suite:s 
				{: 
					
					String corpoFunzione = s.toString().replace("self.", "this.");
					
					StringBuilder sb = new StringBuilder();
					ArrayList<String> pr = UtilsToSymTable.tokenParameters(p.toString(),"#");
			 		String tab=" ";
			 		for(int i=0; i<Integer.parseInt(pr.get(0)); i++){
						tab+="\t";
					}
					
			 		if(n.toString().equals("__init__")){
			 			//costruttore per la funzione
			 			ArrayList<String> par = UtilsToSymTable.tokenParameters(pr.get(1),",");
			 			
			 			for(int i = 0; i < par.size(); i++){
			 				if(par.get(i).equals("Object self")){
			 					par.remove(i);
			 				}
			 			}
			 			
						String functionName = n.toString()+"#"+par.size();
			  			if(Integer.parseInt(pr.get(0))==0)
							functionName = functionName + "#DefaultClass";
			  			//Metto in value il corpo del costruttore..
			  			//SymbolType symbolType=new SymbolType(n,"constructor",corpoFunzione,parWhitoutSELF,"",Integer.parseInt(pr.get(0)),null);
			  			SymbolType symbolType=new SymbolType(n,"constructor",corpoFunzione,par,"",Integer.parseInt(pr.get(0)),null);
			 			parser.symTable.putSymbol(Integer.parseInt(pr.get(0)),functionName,symbolType);
			 			if(Integer.parseInt(pr.get(0))==0) parser.StaticSupport.put(functionName,corpoFunzione);
			  			
			 		}else{
				 		
						//VERIFICO IL TIPO DI RITORNO D1
						int flag=0;
						String firstType=null;
						boolean flag_2 = false;
						//System.out.println("VERIFICA PRESENZA RETURN: ");
						ArrayList<Integer> allKeys = parser.symTable.getAllScope();	
						Iterator<Integer> it = allKeys.iterator();
						while(it.hasNext()){
							Integer numberScoper = it.next();
							//System.out.println("LEVEL VERIFICATED: "+numberScoper);
							Hashtable<String,SymbolType> all = parser.symTable.getSymTable(numberScoper);
							Enumeration<String> k = all.keys();
							while(k.hasMoreElements()){
								String singleK = k.nextElement();
								//System.out.println("KEY::: "+singleK);
								if(singleK.equals("return") || singleK.equals("return ")){
									flag_2 = true;
								}
									
							}
						}
						if(flag_2)
							firstType =  "Object ";
						else
							firstType =  "void ";
						//System.out.println("VERIFICA - PRESENZA RETURN_2: "+firstType);
						
						//VERIFICO LA PRESENZA DI EVENTUALI ARGOMENTI NELLA FUNZIONE
						
				 		if(pr.get(1).equals("null")) //se non ci sono argomenti inserisco solo le parentesi
				 		{
				 			
							ArrayList<String> parameters = new ArrayList<String>();
							ArrayList<Hashtable<String,SymbolType>> array= parser.symTable.getAllSymbol(Integer.parseInt(pr.get(0)));
							
							
							String functionName = n+"#0";
							if(Integer.parseInt(pr.get(0))==0)
								functionName = functionName + "#DefaultClass";
								
							//System.out.println("functionName: " +functionName);
							
							SymbolType symbolType=new SymbolType(n,"function",null,new ArrayList<String>(),firstType,Integer.parseInt(pr.get(0)),null);
				 			parser.symTable.putSymbol(Integer.parseInt(pr.get(0)),functionName,symbolType);
				 			if(Integer.parseInt(pr.get(0))==0) parser.StaticSupport.put(functionName,corpoFunzione);
				 			//System.out.println("GETINDENTATION funzione"+pr.get(0));
				 			sb.append(tab);
				 			sb.append(UtilsToSymTable.getFunctionModifier(n));
				 			sb.append(firstType);
				 			sb.append(" ");
				 			sb.append(symbolType.getName());
				 			sb.append("(");
				 			sb.append(")");
				 			sb.append("{");
				 			sb.append("\n");
				 			sb.append(corpoFunzione);
				 			sb.append("\n");
				 			sb.append(tab);
				 			sb.append("}");
				 			sb.append("\n");
				 		}
				 		else
				 		{
				  			
				  			
				  			ArrayList<String> par = UtilsToSymTable.tokenParameters(pr.get(1),",");
				  			String par_ametri = new String();
				 			
				  			for(int i = 0; i < par.size(); i++){
				 				if(par.get(i).equals("Object self")){
				 					par.remove(i);
				 				}
				 			}
				  			
				  			for(int i = 0; i < par.size(); i++){
				  				par_ametri = par_ametri + par.get(i);
				  				if(i!=par.size()-1)
				 					par_ametri = par_ametri + ",";
				  			}
				 			
							String functionName = n.toString()+"#"+par.size();
							if(Integer.parseInt(pr.get(0))==0)
								functionName = functionName + "#DefaultClass";
				  			
				  			//System.out.println("funcName: " + functionName);
				  			//System.out.println("par_ametri: " + par_ametri);
				  			
				    		SymbolType symbolType=new SymbolType(n,"function",null,par,firstType, Integer.parseInt(pr.get(0)),null);
				 			parser.symTable.putSymbol(Integer.parseInt(pr.get(0)),functionName,symbolType);
				    		if(Integer.parseInt(pr.get(0))==0) parser.StaticSupport.put(functionName,corpoFunzione);
				 						    		
				    		sb.append(tab);
				    		sb.append(UtilsToSymTable.getFunctionModifier(n));
				 			sb.append(firstType);
				 			sb.append(" ");
				 			sb.append(symbolType.getName());
				 			sb.append("(");
				 			sb.append(par_ametri);
				 			sb.append(")");
				 			sb.append("{");
				 			sb.append("\n");
				 			sb.append(corpoFunzione);
				 			sb.append("\n");
				 			sb.append(tab);
				 			sb.append("}");
				 			sb.append("\n");
				 			
				    	}
			 		}
			    	
			    	//Cancello gli eventuali scope di livello inferiore al mio
					Enumeration et = parser.symTable.getScopeSym().keys();
					while(et.hasMoreElements()){
						int currLev = (Integer)et.nextElement();
						//System.out.println("CurrLev: "+currLev);
						//System.out.println("IndentLev: "+pr.get(0));
						if(currLev > Integer.parseInt(pr.get(0))){
							Enumeration ez = parser.symTable.getSymTable(currLev).keys();
							while(ez.hasMoreElements()){
								String currKeyz= (String)ez.nextElement();
								if(parser.symTable.getSymbol(currLev, currKeyz).getOwner()==null){
											//System.out.println("Removing - "+parser.symTable.getSymbol(currLev, currKeyz).getName()+" - frome DEF function");
											parser.symTable.getSymTable(currLev).remove(currKeyz);
								}										
							}
						}
					}
					
					//rimuovo elementi anche dalla parser.scopeHash
					parser.scopeHash.clear();
					
					if(parser.InherSupport.get(n)!=null){
						//System.out.println("METHOD PRESENT!");
					}
					else{
						//System.out.println("I PUT METHOD: "+n.toString());
						//System.out.println("CORPO: "+corpoFunzione);
						parser.InherSupport.put(n,corpoFunzione);
					}
					
					if(Integer.parseInt(pr.get(0))==0){
						RESULT = "";
					}else{
						RESULT = sb.toString();		
					}
			:}
;

parameters		::= LPAREN RPAREN 
						{: 
							//System.out.println("#CUP - parameters:Funzione senza argomenti ");  
							RESULT = String.valueOf(getIndentation())+"#"+"null";
						:} 
					| LPAREN varargslist:v RPAREN 
						{: 
							//System.out.println("#CUP - parameters: Argomenti Funzione: "+ v);
							//String[] var = (String[])v; PER TIRARE FUORI LE SINGOLE VARIABILI
							RESULT=String.valueOf(getIndentation())+"#"+v;	
						:}
;

varargslist		::= positional_arguments:d 
						{: 
								StringBuilder sb = new StringBuilder();
								ArrayList<String> argoments = UtilsToSymTable.tokenParameters(d.toString(),",");
								for(int i=0; i<argoments.size(); i++){
									parser.symTable.putSymbol(getIndentation()+1,argoments.get(i),new SymbolType(argoments.get(i),"Object",null,null,null,getIndentation()+1,null));
									sb.append("Object "+argoments.get(i));
									if(i!=argoments.size()-1){
										sb.append(",");
									}
								}
								RESULT=sb;
						:}
					| positional_arguments:d COMMA MULT NAME:n 
						{: 
								StringBuilder sb = new StringBuilder();
								ArrayList<String> argoments = UtilsToSymTable.tokenParameters(d.toString(),",");
								for(int i=0; i<argoments.size(); i++){
									parser.symTable.putSymbol(getIndentation()+1,argoments.get(i),new SymbolType(argoments.get(i),"Object",null,null,null,getIndentation()+1,null));
									sb.append("Object "+argoments.get(i));
									sb.append(",");
								}
								
								//inserisco pure *name
								parser.symTable.putSymbol(getIndentation()+1,n,new SymbolType(n,"Tupla",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n);
								
								RESULT=sb;
														 
						:}
					| positional_arguments:d COMMA MULTMULT NAME:n 
						{: 
								
								StringBuilder sb = new StringBuilder();
								ArrayList<String> argoments = UtilsToSymTable.tokenParameters(d.toString(),",");
								for(int i=0; i<argoments.size(); i++){
									parser.symTable.putSymbol(getIndentation()+1,argoments.get(i),new SymbolType(argoments.get(i),"Object",null,null,null,getIndentation()+1,null));
									sb.append("Object "+argoments.get(i));
									sb.append(",");
								}
								
								//inserisco pure **name
								parser.symTable.putSymbol(getIndentation()+1,n,new SymbolType(n,"PDictionary",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n);


								RESULT=sb;
							
						:}
					| positional_arguments:d COMMA MULT NAME:n1 COMMA MULTMULT NAME:n2 
						{: 
								
								StringBuilder sb = new StringBuilder();
								ArrayList<String> argoments = UtilsToSymTable.tokenParameters(d.toString(),",");
								for(int i=0; i<argoments.size(); i++){
								//	parser.symTable.putSymbol(getIndentation()+1,argoments.get(i),new SymbolType(argoments.get(i),"Object",null,null,null,getIndentation()+1,null));
									sb.append("Object "+argoments.get(i));
									sb.append(",");
								}
								
								//inserisco pure *name
								parser.symTable.putSymbol(getIndentation()+1,n1,new SymbolType(n1,"Tupla",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n1 +",");
								
								//inserisco pure **name
								parser.symTable.putSymbol(getIndentation()+1,n2,new SymbolType(n2,"PDictionary",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n2);

								RESULT=sb;
														
						:}
					| MULT NAME:n 
						{:  
								//inserisco pure *name
								parser.symTable.putSymbol(getIndentation()+1,n,new SymbolType(n,"Tupla",null,null,null,getIndentation()+1,null));
								
								RESULT="Object "+n;
									
						:}
					| MULT NAME:n1 COMMA MULTMULT NAME:n2 
						{: 
								
								StringBuilder sb = new StringBuilder();
								
								//inserisco pure *name
								parser.symTable.putSymbol(getIndentation()+1,n1,new SymbolType(n1,"Tupla",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n1 +",");
								
								//inserisco pure **name
								parser.symTable.putSymbol(getIndentation()+1,n2,new SymbolType(n2,"PDictionary",null,null,null,getIndentation()+1,null));
								sb.append("Object "+n2);
								
								RESULT=sb;
						
						:}
					| MULTMULT NAME:n 
						{: 
								parser.symTable.putSymbol(getIndentation()+1,n,new SymbolType(n,"PDictionary",null,null,null,getIndentation()+1,null));								
								RESULT="Object "+n;
						:}
;
							
positional_arguments	::= positional_arguments:dr COMMA single_parameter:d 
								{: 
									RESULT=dr+","+d;
								:} 
							| single_parameter:d 
								{: 
									RESULT=d;
								:}						
;

single_parameter		::= fpdef:f 
								{: 
									RESULT=f;
								:} 
							| fpdef:f ASSIGN test:t 
								{: 
									semanticAlert("Funzione con parametro ed assegnazione nel prototipo non supportata in JAVA");
									RESULT=f;
								:}
;

fpdef					::= NAME:n 
								{:
									RESULT=n;
								:} 
							| number:n 
								{: 
									RESULT = n;
								:} 
							| STRING:s 
								{: 
									RESULT = s;
								:}
							| LPAREN fplist:f RPAREN 
								{: 
									
									RESULT=f;
								:}
							| NAME:n DOT:d NAME:n2
							{: 
								RESULT = n+d+n2;
							:} 
;


fplist					::= fplist:fl COMMA fpdef:f  
								{:
									RESULT = fl+","+f;
								:}
							| fpdef:f 
								{: 
									RESULT =f;
								:} 
;


stmt			::= simple_stmt:s 
						{: 	
							RESULT = s;	
						:} 
					| compound_stmt:c 
						{: 
							RESULT = c;	
						:} 
;


/* 
*************   Gestione di tutti i BLOCCHI SEMPLICI.... (espressioni, operatori, etc...)  ***************
*/

simple_stmt		::= small_stmt:s NEWLINE 
					{:
						RESULT = s;
					:} 
					| small_stmt:s SEMI NEWLINE {:
					 	
					  	RESULT=s;
					:}
					| small_stmt:s small_stmt_kleine:sk NEWLINE 
					{:
					    RESULT = s.toString()+sk.toString();
					:}
					| small_stmt:s small_stmt_kleine:sk SEMI NEWLINE 
					{:
					    RESULT = s.toString()+sk.toString();
					
					:}
;

small_stmt_kleine	::= SEMI small_stmt:s 
					{:
						RESULT=s;
					
					:} 
					| small_stmt_kleine:sk SEMI small_stmt:s {:
					
					    RESULT=sk.toString()+s.toString();
					:}
;

small_stmt		::= expr_stmt:e 
						{: 
							if(getIndentation()==0){
	                    		parser.arrayMain.add(e.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT = e; 
		                    } 
						:}
					| print_stmt:p 
					    {: 
							if(getIndentation()==0){
	                    		parser.arrayMain.add(p.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT = p; 
		                    } 	
					    :}
					| range_stmt:r 
						{: 
							String message="RANGE: CANNOT RESOLVE THIS INSTRUCTION\n"; 
							semanticAlert(message);
							if(getIndentation()==0){
	                    		parser.arrayMain.add("//ERROR ON RANGE: AUTO GENERATE COMMENT\n");
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT="//ERROR ON RANGE: AUTO GENERATE COMMENT\n";
		                    } 
						:}
					| del_stmt:d 
					{: 
							String message="DEL: CANNOT RESOLVE THIS INSTRUCTION\n"; 
							semanticAlert(message);
							
							if(getIndentation()==0){
	                    		parser.arrayMain.add("//ERROR ON DEL: AUTO GENERATE COMMENT\n");
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT="//ERROR ON DEL: AUTO GENERATE COMMENT\n"; 
		                    } 					
					:}
					| PASS:p 
					{: 
							if(getIndentation()==0){
	                    		parser.arrayMain.add("{ };");
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT="{ };";
		                    } 
					:}
					| flow_stmt:f 
						{: 
							String tab=" ";
							for(int i=0; i<getIndentation(); i++)
			 				{
								tab+="\t";
							}  
							
							if(getIndentation()==0){
	                    		parser.arrayMain.add(tab.toString()+f.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT=tab.toString()+f.toString();
		                    } 
						:}
					| import_stmt:i 
						{:  
							if(getIndentation()==0){
	                    		parser.arrayMain.add(i.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT=i.toString();
		                    } 
						:}
         			| assert_stmt:a 
         				{: 
		                    if(getIndentation()==0){
	                    		parser.arrayMain.add(a.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT=a.toString();
		                    } 
         				:}
         			| global_stmt:g 
         				{:  
		                    if(getIndentation()==0){
	                    		parser.arrayMain.add(g.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT=g.toString();
		                    }   
         				:}
         			| exec_stmt:e 
         				{:  
         					 if(getIndentation()==0){
 	                    		parser.arrayMain.add(e.toString());
 		                    	RESULT = "";
 	                    	}
 	                    	else{
 	                    		RESULT=e.toString();
 		                    } 
         				:}
         			| comment:c 
         				{:  
 		                   if(getIndentation()==0){
	                    		parser.arrayMain.add(c.toString());
		                    	RESULT = "";
	                    	}
	                    	else{
	                    		RESULT=c.toString();
		                    } 
         				:}
;


//Gestione ESPRESSIONI
expr_stmt	::= testlist:t 
					{:
						
						String tab=" ";
						for(int i=0; i<getIndentation(); i++){
							tab+="\t";
						}
						
						boolean flag=false;
						boolean classCast=false;
						boolean classInit=false;
						int par=0;
						ArrayList<String> a = UtilsToSymTable.tokenParameters(t.toString(),".");
						
						if(a.size()>1){
							//System.out.println("TO SPLIT: "+t.toString());
							//System.out.println("SPLIT_1"+a.toString());
							ArrayList<String> b = UtilsToSymTable.tokenParameters(a.get(1),"(");
							//System.out.println("SPLIT_2"+b.toString());
						
							//Verifica sulla dichiarazione dell'oggetto..
							if(parser.symTable.checkObject(a.get(0))){
								if(parser.symTable.checkClass(a.get(0))){
									//System.out.println("IT'S A CLASS!");
									if(b.get(0).equals("__init__")){
										classInit=true;
										String argvs = "";
										String pas="";
										if(b.size()!=0){
											ArrayList<String> argv = UtilsToSymTable.tokenParameters(b.get(1),")");
											if(!(pas=(checkPar(argv,getIndentation(),a.get(0)))).equals("")){
											//argvs=argv.get(0);
											argvs=pas;
											RESULT = tab+"super("+argvs+");\n";
											//System.out.println("I SET: super("+argvs+");\n");
											//System.out.println("I SET (ARGVS): "+RESULT);
											}
											else{
												semanticAlert("Error Setting Constructor parameters!");
												RESULT = tab+"//ERROR SETTING CONSTRUCTOR PARAMETERS\n";
											}
										}else{
											//System.out.println("NO ARGVS!");
											RESULT = tab+"super("+argvs+");\n";
											//System.out.println("I SET: super("+argvs+");\n");
										}
									}
										
									else
										classCast=true;
								}
								if(b.size()<2 && !classInit){ //Si tratta di un attributo..
									//System.out.println("It's an attribute!");
									//Verifica sull'esistenza dell'entità (attributo o funzione)..
									//System.out.println("#I_SEARCH::: "+t.toString()+"#"+parser.symTable.getClass(a.get(0)));
									if(classCast){
										//String newt = t.toString().replace(".","_");
										//System.out.println("AAA:"+newt+";\n");
										semanticAlert("OPERATION NOT ALLOWED!");
										RESULT= tab+"//OPERATION NOT ALLOWED!\n";
									}
									else{
										if(parser.symTable.checkEntity(t.toString()+"#"+parser.symTable.getClass(a.get(0)))){
											 //Verifica appartenenza alla classe per effettuare il casting..
											if(parser.symTable.getClass(a.get(0))!=null){
													//System.out.println("AAA: ("+parser.symTable.getClass(a.get(0))+")"+t+";\n");
													RESULT= tab+"("+parser.symTable.getClass(a.get(0))+")"+t+";\n";
											}
											else{
												//System.out.println("ERROR GETTING OWNER\n");
												RESULT= tab+"//ERROR GETTING CLASS FOR CASTING IN ENTITY "+t.toString()+"\n";
											}
									}
									else{
										//System.out.println("ERROR RESOLVING ENTITY\n");
										RESULT= tab+"//ERROR ERROR RESOLVING ENTITY "+t.toString()+"\n";
									}	
									}
									
									
								}
								else if(b.size()>=2 && !classInit){ //b.size() >=2 quindi si tratta di un metodo..
									if(classCast){
										/*System.out.println("It's a method!!");
										String newt = t.toString().replace(".","_");
										System.out.println("AAAAAAAAAAAAAAAAAAA: "+newt);
										System.out.println("AAAMM:"+newt+";\n");
										RESULT=newt+";\n"; */
										semanticAlert("OPERATION NOT ALLOWED!");
										RESULT= tab+"//OPERATION NOT ALLOWED!\n";
									}
									else{
									//System.out.println("It's a method!!");
									ArrayList<String> c = UtilsToSymTable.tokenParameters(b.get(1),")");
									//System.out.println("SPLIT_3"+c.toString());
									if(!c.isEmpty()){ //Se non è vuoto significa che ho parametri..
										ArrayList<String> d = UtilsToSymTable.tokenParameters(c.get(0),",");
										//System.out.println("SPLIT_4 [Parameters]"+d.toString()+" SIZE: "+d.size());
										//Verifica sull'esistenza dell'entità (funzione)..
										//System.out.println("Checking: "+b.get(0)+"#"+d.size()+"#"+parser.symTable.getClass(a.get(0)));
										if(parser.symTable.checkMethod(b.get(0)+"#"+d.size()+"#"+parser.symTable.getClass(a.get(0)))){
											//System.out.println("PAR!=: "+d.toString());
											
											
											//Eseguo un check sui parametri che ho passato per vedere se esistono..

											/*TODO: Implementare algoritmo per controllare i parametri passati al metodo:
											 * Se si tratta di valori lasciamoli passare, se passo variabili devo controllare
											 * che esistono!! :D:D
											 */
											
											for(int i=0;i<d.size();i++){
												//COMMENTATO CHECK SUI PARAMETRI..
											//	if(parser.symTable.checkEntity(d.get(i))){
													//System.out.println("aaaa: (("+parser.symTable.getClass(a.get(0))+")"+a.get(0)+")."+a.get(1));
													//RESULT="("+parser.symTable.getClass(a.get(0))+")"+t+";\n";
													RESULT= tab+"(("+parser.symTable.getClass(a.get(0))+")"+a.get(0)+")."+a.get(1) + ";\n";
												//}
												//else{
												//	RESULT="//ERROR RESOLVING METHOD "+b.get(0)+"\n"; 
												//}
											}
											//RESULT="("+parser.symTable.getClass(a.get(0))+")"+t+";\n";
										}else{
											//System.out.println("Function not found!");
										  	//System.out.println("//ERROR RESOLVING METHOD "+b.get(0)+"\n");
											RESULT= tab+"//ERROR RESOLVING METHOD "+b.get(0)+"\n";
										}
									
									}else{
										 //System.out.println("No parameters: I search: "+b.get(0)+"#0#"+parser.symTable.getClass(a.get(0)));
										 //Verifica sull'esistenza dell'entità (funzione)..
										 if(parser.symTable.checkMethod(b.get(0)+"#0#"+parser.symTable.getClass(a.get(0)))){
										 		//System.out.println("FOUND!!");
										 		//System.out.println("tttt: (("+parser.symTable.getClass(a.get(0))+")"+a.get(0)+")."+a.get(1));
										 		//RESULT="("+parser.symTable.getClass(a.get(0))+")"+t+";\n";
										 		RESULT = tab+"(("+parser.symTable.getClass(a.get(0))+")"+a.get(0)+")."+a.get(1) + ";\n";
										 }
										 else{
										  	//System.out.println("Function not found!");
										  	//System.out.println("//ERROR RESOLVING METHOD "+b.get(0)+"\n");
											RESULT= tab+"//ERROR RESOLVING METHOD "+b.get(0)+"\n"; 
										 }
										 
										 } 
									}	 
										 
								}//Chiude b.size()
							}else{
								//System.out.println("//ERROR RESOLVING OBJECT "+a.get(0)+"\n");
								RESULT= tab+"//ERROR RESOLVING OBJECT "+a.get(0)+"\n"; 
							}
								
						}else{
							//caso in cui NON CI SONO PUNTI....
							//es: invoco funzione -> func(c,v,b)
							 ArrayList<String> array=UtilsToSymTable.tokenParameters(a.get(0),"();");
                                                                         
                             int numFunctionParam = 0;
                             if(array.size()>1){
                                     ArrayList<String> params = UtilsToSymTable.tokenParameters(array.get(1),",");
                                     numFunctionParam = params.size();
                             }
                             //System.out.println("numFunctionParam: " +numFunctionParam);
                             
                             String className2 = null;
                             //cerco nello stella stessa classe
                             boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),null, getIndentation(),parser.getSymbolTable());;
                             if(!funcOK){
                            	 //cerco tra le classi ereditate
                            	 int caught = -1;
                            	 if(parser.ereditClassToFunctionInvocation.size()!=0){
	         						for(int qw=0; qw<parser.ereditClassToFunctionInvocation.size(); qw++){
	         							funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),parser.ereditClassToFunctionInvocation.get(qw), getIndentation(),parser.getSymbolTable());
	                                    if(funcOK)
	                                    	caught = qw;
	         						}
	                             }
                            	 if(caught!=-1){
                            		className2 = parser.ereditClassToFunctionInvocation.get(caught); 
                            	 }else {
                            		 //cerco nella classe di default
                            		funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),"DefaultClass", getIndentation(),parser.getSymbolTable());
                            		if(funcOK)
                            			className2 = "DefaultClass";
                            	 }
                             }
                             //System.out.println("className2: " +className2);
                                                                   
                             if(funcOK && className2.equals("DefaultClass"))
                             	RESULT = tab+"DefaultClass."+t.toString()+";\n";
                             else if(funcOK && !className2.equals("DefaultClass"))
                            	RESULT = tab+t.toString()+";\n";
                             else
                             	RESULT = tab+"//ERROR - Istruction dont'allowed! \n ";
							 
						}

					:}
				| testlist:t1 augassign:a testlist:t2 
					{:
						
						String tab=" ";
				 		for(int i=0; i<getIndentation(); i++){
							tab+="\t";
						}
						
						StringBuilder sb = new StringBuilder();
						//System.out.println("#expr_stmt: 2___  "+t1+a+t2); //RIVEDEREEEEEEE*******************
						String options=new String();
						ArrayList<String> arrayVar1=UtilsToSymTable.tokenParameters(t1.toString(),".");
					    ArrayList<String> arrayVar2=UtilsToSymTable.tokenParameters(t2.toString(),".");
					    Boolean flag1=false,flag2=false;
						if(arrayVar1.size()>1){
							//probabile caso: p.attributo
							String classType=UtilsToSymTable.getVariableType(arrayVar1.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							flag1=UtilsToSymTable.isCorrectClassAttributeUsed(arrayVar1.get(1),classType,getIndentation(),parser.getSymbolTable());
						}
						if(arrayVar2.size()>1){
							//probabile caso: p.attributo
							String classType=UtilsToSymTable.getVariableType(arrayVar1.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							flag2=UtilsToSymTable.isCorrectClassAttributeUsed(arrayVar1.get(1),classType,getIndentation(), parser.getSymbolTable());	
							}
						if((flag1)&&(flag2))
						{
							//CASO: p.attributo+=q.attributo
							
							String var1=CheckType.check(arrayVar1.get(1));
							String var2=CheckType.check(arrayVar2.get(1));
							String value1 = UtilsToSymTable.getValue(var1,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							String value2 = UtilsToSymTable.getValue(var2,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
							String valueType1=CheckType.check(value1);
							String valueType2=CheckType.check(value2);
							if(valueType1.equals(valueType2))
								options=valueType1+"#VALUEATTRIBUTE";
							else
								options="ERROR";			
						}
						else if((flag1)&&(!flag2))
						{
							//CASO: p.attributo+=x oppure COSTANTE
						
						
						}
						else if((flag1)&&(!flag2))
						{
							//CASO: x+=p.attributo 
						
						
						}
						else if((!flag1)&&(!flag2))
						{
							String var1=CheckType.check(t1.toString());
							String var2=CheckType.check(t2.toString());
							if((var1.equals(var2))&&(!var1.equals("Object"))&&(!var2.equals("Object")))
							{
								options="SAME_TYPE_NO_OBJECT";
							}
							else{
								if((var1.equals("Object"))&&(var2.equals("Object")))
								{
									//CASO TIPO: x+=y (entrambi Object)
									String value1 = UtilsToSymTable.getValue(t1.toString(),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
									String value2 = UtilsToSymTable.getValue(t2.toString(),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
									String valueType1=CheckType.check(value1);
									String valueType2=CheckType.check(value2);
									if(valueType1.equals(valueType2)){
										options=valueType1+"#SAME_TYPE_OBJECT";
									}
										
									else
										options="ERROR";
								}
								else if((var1.equals("Object"))&&(!var2.equals("Object")))
								{
									String value1 = UtilsToSymTable.getValue(t1.toString(),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
									String valueType1=CheckType.check(value1);
									if(valueType1.equals(var2)){
										options=valueType1+"#SAME_TYPE_OBJECT";
									}
									else
										options="ERROR";
								}
								else if((var2.equals("Object"))&&(!var1.equals("Object")))
								{
									String value2 = UtilsToSymTable.getValue(t2.toString(),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
									String valueType2=CheckType.check(value2);
									if(valueType2.equals(var1)){
										options=valueType2+"#SAME_TYPE_OBJECT";
									}
									else
										options="ERROR";
								}
								
							}
						}
							
						
						
						//*********************************************************************
						
						if(a.equals("+="))
						{
							if(options.equals("SAME_TYPE_NO_OBJECT"))
							{
								RESULT= tab+t1+"="+t1+"+"+t2+";";
							}
							else if(options.contains("SAME_TYPE_OBJECT"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+"("+array.get(0)+")"+t1+"+"+"("+array.get(0)+")"+t2+";";
							}
							else if(options.contains("VALUEATTRIBUTE"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+t1+"+"+t2+";";
							}
							else if(options.equals("ERROR"))
							{
								semanticAlert("ERROR IN INSTRUCTION");
								RESULT= tab+"//ERROR IN INSTRUCTION";	
							}
							
						}
						if(a.equals("-="))
						{
							if(options.equals("SAME_TYPE_NO_OBJECT"))
							{
								RESULT= tab+t1+"="+t1+"-"+t2+";";
							}
							else if(options.contains("SAME_TYPE_OBJECT"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+"("+array.get(0)+")"+t1+"-"+"("+array.get(0)+")"+t2+";";
							}
							else if(options.contains("VALUEATTRIBUTE"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+t1+"-"+t2+";";
							}
							else if(options.equals("ERROR"))
							{
								semanticAlert("ERROR IN INSTRUCTION");
								RESULT= tab+"//ERROR IN INSTRUCTION";	
							}
						}
						if(a.equals("*="))
						{
							if(options.equals("SAME_TYPE_NO_OBJECT"))
							{
								RESULT= tab+t1+"="+t1+"*"+t2+";";
							}
							else if(options.contains("SAME_TYPE_OBJECT"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+"("+array.get(0)+")"+t1+"*"+"("+array.get(0)+")"+t2+";";
							}
							else if(options.contains("VALUEATTRIBUTE"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+t1+"*"+t2+";";
							}
							else if(options.equals("ERROR"))
							{
								semanticAlert("ERROR IN INSTRUCTION");
								RESULT= tab+"//ERROR IN INSTRUCTION";	
							}
						}
						if(a.equals("/="))
						{
							if(options.equals("SAME_TYPE_NO_OBJECT"))
							{
								RESULT= tab+t1+"="+t1+"/"+t2+";";
							}
							else if(options.contains("SAME_TYPE_OBJECT"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+"("+array.get(0)+")"+t1+"/"+"("+array.get(0)+")"+t2+";";
							}
							else if(options.contains("VALUEATTRIBUTE"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+t1+"/"+t2+";";
							}
							else if(options.equals("ERROR"))
							{
								semanticAlert("ERROR IN INSTRUCTION");
								RESULT= tab+"//ERROR IN INSTRUCTION";	
							}
						}
						if(a.equals("%="))
						{
							if(options.equals("SAME_TYPE_NO_OBJECT"))
							{
								RESULT= tab+t1+"="+t1+"%"+t2+";";
							}
							else if(options.contains("SAME_TYPE_OBJECT"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+"("+array.get(0)+")"+t1+"%"+"("+array.get(0)+")"+t2+";";
							}
							else if(options.contains("VALUEATTRIBUTE"))
							{
								ArrayList<String> array=UtilsToSymTable.tokenParameters(options,"#");
								RESULT= tab+t1+"="+t1+"%"+t2+";";
							}
							else if(options.equals("ERROR"))
							{
								semanticAlert("ERROR IN INSTRUCTION");
								RESULT= tab+"//ERROR IN INSTRUCTION";	
							}
						}
						
						
					:}
				| testlist:t assign_recoursive:a 
				{:         
                    
/*                      
                        //l'ultimo parametro dell'ArrayList "parameters" puo' essere
                        //1) o un singolo valore [es:un numero, una stringa, etc...]
                        //2) o una tupla [es: (1,2,3,4,'ciao')] NB: anche di tipi diversi! :O
                        //3) o una lista [es: [1,2,"STR"]
                        //4) o un dizionario [es: {"ca":1, "sa":2} ]
                        //5) o una espressione....
                        //6) assegnazione del tipo p.x=y
                        //7) x=metodo()
                        //8) x=altraIstanza.attributo;
                        //9) p.attributo=x;     
                        //es: x = 3*4*(1,2) + y + y*3 -> risultato -> Object x = new Tupla();
                                                                                        //x.result("3*4*(1,2) + (4,5) + (4,5)*3");
                        //es: y = 3*2,2 -> definizio TUPLA (6,2) 
                        //es: c = (1,2) + y -> result
                        //es: c = y[1:2]
                        //es: x = 5*j -> con j=tupla o lista o Integer
                        //es: v = c[2] -> con c Tupla o Lista
                        //es: d['key'] = 34.78 -> con d dizionario
                        //es: v = x (con x Argomento di una Funzione) -> Object v = x;
                        //es: v = x + y (con x e y Argomenti di una Funzione) -> Object v = x.toString() + y.toString();
                        //es: x,y,z = t (con t tupla di dimensione 3)
                        //es: t = 1,2,3 -> t � tupla (cio� si possono anche NON mettere le parentesi tonde)
                        //es: ANNIDAMENTO! :O
                        //es: v = (1,2,x) -> Object v = new Tupla("1,2,x");
                        //es: c = {4,4} -> � un set
                        //es: lista = [1,2,3,4]
                        //es: k = set([1,2,3,2]) -> � un set
*/                      
                    
					String tab=" ";
			 		for(int i=0; i<getIndentation(); i++){
						tab+="\t";
					}
					                    
                    StringBuilder sb = new StringBuilder();

					
					String all = t.toString() + a.toString();
					String newParameters = all.replace("self.","");
					
                    ArrayList<String> parameters_with_self=UtilsToSymTable.tokenParameters( t.toString() + a.toString(), "=");
            		ArrayList<String> parameters=UtilsToSymTable.tokenParameters( newParameters, "=");
                    
                    String lastParameters = parameters.get(parameters.size()-1);

                    ArrayList<String> className = UtilsToSymTable.tokenParameters(lastParameters,"();");
                    
                    boolean isClass=UtilsToSymTable.isExistClass(className.get(0),getIndentation(), parser.getSymbolTable());
                    
                    if(isClass){
                    	//System.out.println("CLASSE TROVATA! " );
                    		boolean istanzaOK = true;
                    		
                            int numeroDiParam=0;
                            
                            if(className.size()>1){
                                    ArrayList<String> paramClass = UtilsToSymTable.tokenParameters(className.get(1),",");
                                    
                                    String constructor = className.get(0)+"#"+String.valueOf(paramClass.size())+"#"+className.get(0);
                                    //System.out.println("constructor: " +constructor );
                                    boolean isCorrectNumberParameters = UtilsToSymTable.isExistFunction(constructor,getIndentation(), parser.getSymbolTable());
                                    
                                    if(isCorrectNumberParameters==false){
                                    	istanzaOK = false; //is an ERROR
                                    }
                                    else{
                                        numeroDiParam=paramClass.size();
                                    }
                            }else{
                            	String constructor = className.get(0)+"#0#"+className.get(0);
                            	boolean isCorrectNumberParameters = UtilsToSymTable.isExistFunction(constructor,getIndentation(), parser.getSymbolTable());
                                
                                if(isCorrectNumberParameters==false){
                                	istanzaOK = false; //is an ERROR
                                }
                            }

                        
                            if(istanzaOK){
                            		//System.out.println("istanzaOK " );
                                    //ciclo for usato per assegnazione multipla
                                    for(int i = 0; i<parameters.size()-1;i++){
                                    		//className.get(1) = contiene i parametri dentro le (...)
                                    		//verifico che tutti i parametri passati al costruttore esistono
                                    		boolean isOKOK = true;
                                    		if(className.size()>1){
                                    			isOKOK = UtilsToSymTable.isCorrectListOfParametersInsideFunction(className.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                    		}
                                    		
                                    		if(isOKOK){
	                                            boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	                                    
	                                            sb.append(tab);
	                                            if(flag==false){
	                                            	sb.append("Object ");
	                                            }
	                                    
	                                            sb.append(parameters.get(i));
	                                            sb.append(" = ");
	                                            sb.append("new "+className.get(0));
	                                            
	                                            if(numeroDiParam==0){
	                                               sb.append("();\n");
	                                            }
	                                            else{
	                                            	String allParamets = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(className.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	                                                sb.append("("+allParamets+");\n");
	                                            }
	                                            
	                                            parser.symTable.putSymbol(getIndentation(),parameters.get(i),new SymbolType(parameters.get(i),className.get(0),null,null,null,getIndentation(),null));
	                                            parser.symTable.setIstanceAttribute(parameters.get(i),className.get(0),getIndentation());
                                    
                                    		}
                                    		else
                                    			 sb.append(tab+"//ERROR IN METHOD INVOCATION: NUMERO DI PARAMETRI DEL COSTRUTTORE SBAGLIATI\n");
                                    }
                            }
                            else
                                    sb.append(tab+"//ERROR IN METHOD INVOCATION: NUMBER OF PARAMETERS MISMATCH\n");     
                    
                    
                    }else if(lastParameters.equals("[]")){
                    	//System.out.println("GENERIC-LIST-VUOTO");
                    	//per ogni parametro a sinistra (NB: l'assegnazione potrebbe essere ricorsiva)
                        for(int i = 0; i<parameters.size()-1;i++){
                        	StringBuilder sb2 = getTypeOfAssignator(parameters.get(i));
                        	ArrayList<String> splitStringBuilder = UtilsToSymTable.tokenParameters(sb2.toString(),"#");
                        	sb.append(tab);
                        	sb.append(UtilsToSymTable.getStringBuilderModelsEmpty("GenericList", splitStringBuilder, parameters_with_self.get(i), getIndentation(), parser.symTable, parser.ereditClassToFunctionInvocation));
                        }
                    }else if(lastParameters.equals("()")){
                    	//System.out.println("TUPLA-VUOATA");
                    	for(int i = 0; i<parameters.size()-1;i++){
                    		StringBuilder sb2 = getTypeOfAssignator(parameters.get(i));
                    		ArrayList<String> splitStringBuilder = UtilsToSymTable.tokenParameters(sb2.toString(),"#");
                    		sb.append(tab);
                    		sb.append(UtilsToSymTable.getStringBuilderModelsEmpty("Tupla", splitStringBuilder, parameters_with_self.get(i), getIndentation(), parser.symTable, parser.ereditClassToFunctionInvocation));
                        }
                    	
                    }else if(lastParameters.equals("{}")){
                    	//System.out.println("PDICTIONARY-VUOTO");
                    	for(int i = 0; i<parameters.size()-1;i++){
                    		StringBuilder sb2 = getTypeOfAssignator(parameters.get(i));
                    		ArrayList<String> splitStringBuilder = UtilsToSymTable.tokenParameters(sb2.toString(),"#");
                    		sb.append(tab);
                    		sb.append(UtilsToSymTable.getStringBuilderModelsEmpty("PDictionary", splitStringBuilder, parameters_with_self.get(i), getIndentation(), parser.symTable, parser.ereditClassToFunctionInvocation));
                        }
                    	
                    }else{
                            //per ogni parametro a sinistra (NB: l'assegnazione potrebbe essere ricorsiva)
                            for(int i = 0; i<parameters.size()-1;i++){
                            		
                            		
                                    StringBuilder sb2 = getTypeOfAssignator(parameters.get(i));
                                    
                                    //System.out.println("getTypeOfAssignator: "+sb2.toString());
                                    
                                    if(sb2!=null){
                                            ArrayList<String> splitStringBuilder = UtilsToSymTable.tokenParameters(sb2.toString(),"#");
                                            
                                            if(splitStringBuilder.get(0).equals("ERROR")){
                                                    
                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION: AUTO GENERATE CODE\n");
                                                    
                                            }else if(splitStringBuilder.get(0).equals("TUPLA-UNPACKING")){
                                            
                                                    //in questo caso lastParameters deve essere per forza una TUPLA
                                                    //che contiene un numero di elementi pari a ci� che c'� a sinistra
                                                    //dell'operatore assegnazione
                                                    
                                                    //x,y,z = t
                                                    
                                                    ArrayList<String> values = UtilsToSymTable.getTuplaValue(lastParameters,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                    
                                                    if(values!=null){
                                                    
                                                    		ArrayList<String> parametersSX_with_self=UtilsToSymTable.tokenParameters( parameters_with_self.get(i), ",");
                                                        
                                                    		if(parametersSX_with_self.size()==values.size()){
	                                                            for(int x = 0; x<values.size(); x++){
	                                                                    boolean found = UtilsToSymTable.isExist(splitStringBuilder.get(x+1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);                                                                    
	                                                                    
	                                                                    if(found){
	                                                                            //sb.append(splitStringBuilder.get(x+1));
	                                                                    		sb.append(tab);
	                                                                    		sb.append(parametersSX_with_self.get(x));
	                                                                            sb.append("=");
	                                                                            sb.append(values.get(x)+";\n");
	                                                                    }else{
	                                                                            //Devo mettere "Object" davanti alla variabile
	                                                                            //Object x = value(x);
	                                                                    		sb.append(tab);
	                                                                            sb.append("Object ");
	                                                                            //sb.append(splitStringBuilder.get(x+1));
	                                                                            sb.append(parametersSX_with_self.get(x));
	                                                                            sb.append("=");
	                                                                            sb.append(values.get(x)+";\n");
	                                                                    }
	                                                                    
	                                                                    //parser.symTable.putSymbol(getIndentation(),splitStringBuilder.get(x+1),new SymbolType(splitStringBuilder.get(x+1),CheckType.check(values.get(x)),values.get(x),null,null,getIndentation(),null));
	                                                                    parser.symTable.putSymbol(getIndentation(),parametersSX_with_self.get(x),new SymbolType(parametersSX_with_self.get(x),CheckType.check(values.get(x)),values.get(x),null,null,getIndentation(),null));
	                                                                    
	                                                            }
                                                    		}else{
                                                    			sb.append(tab+"//ERROR IN VARIABLE DEFINITION on TUPLA UNPUCKING - Different numbers of parameters\n");
                                                    		}
                                                            
                                                    }else{
                                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION: AUTO GENERATE CODE\n");
                                                    }
                                                    
                                            
                                            }else if(splitStringBuilder.get(0).equals("DICTIONARY-ASSIGNAMENT")){
                                            
                                            
                                                    //**** gestione chiave... se e' una stringa: ****
                                                                    
                                                    String checkKey = CheckType.check(splitStringBuilder.get(2));
                                                    String newKey = new String();
                                                    if(checkKey.equals("String"))
                                                            newKey = formatString(splitStringBuilder.get(2));
                                                    else
                                                            newKey = splitStringBuilder.get(2);
                                                    
                                                    //***** fine gestione key ***********************
                                                    
                                                    
                                                    
                                                    //**** gestione Values... se e' una stringa: ****
                                                    
                                                    String checkValue = CheckType.check(lastParameters);
                                                    String newValue = new String();
                                                    if(checkValue.equals("String"))
                                                            newValue = formatString(lastParameters);
                                                    else
                                                            newValue = lastParameters;
                                                    
                                                    //***** fine gestione Value ***********************
                                            
                                                    
                                                    //ho la certezza che si tratta di un inserimento di un nuovo elemento
                                                    //dentro un dizionario... devo verificare per� che la variabile
                                                    //coinvolta a sinitra sia un dizionario
                                                    
                                                    boolean found = UtilsToSymTable.isExist(splitStringBuilder.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                    if(found){
                                                            //se esiste -> vedo se � gi� di tipo dizionario
                                                            String type = UtilsToSymTable.getVariableType(splitStringBuilder.get(1),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                            
                                                            if(type.equals("PDictionary")){
                                                            		sb.append(tab);
                                                                    sb.append("((PDictionary)"+splitStringBuilder.get(1)+")");
                                                                    sb.append(".insertNewObject("+newKey+","+newValue+");\n");
                                                                    
                                                            }else{
                                                            		sb.append(tab);
                                                                    sb.append( splitStringBuilder.get(1) + " = new PDictionary();\n");
                                                                    sb.append(tab);
                                                                    sb.append("((PDictionary)"+splitStringBuilder.get(1)+")");
                                                                    sb.append(".insertNewObject("+newKey+","+newValue+");\n");
                                                                    
                                                                    //sb.append(".insertNewObject("+splitStringBuilder.get(2)+","+lastParameters+");\n");
                                                                    
                                                            }
                                                            
                                                    }else{
                                                    		sb.append(tab);
                                                            sb.append("Object "+ splitStringBuilder.get(1) + " = new PDictionary();\n");
                                                            sb.append(tab);
                                                            sb.append("((PDictionary)"+splitStringBuilder.get(1)+")");
                                                            sb.append(".insertNewObject("+newKey+","+newValue+");\n");
                                                    }
                                                    
                                                    //String newValueToInsertInToSymTable = UtilsToSymTable.getValueModels("insertNewObject",splitStringBuilder.get(2),lastParameters,splitStringBuilder.get(1),getIndentation(), parser.getSymbolTable());
                                                    
                                                    String newValueToInsertInToSymTable = UtilsToSymTable.getValueModels("insertNewObject",newKey,newValue,splitStringBuilder.get(1),getIndentation(), parser.getSymbolTable());
                                                    
                                                    parser.symTable.putSymbol(getIndentation(),splitStringBuilder.get(1),new SymbolType(splitStringBuilder.get(1),"PDictionary",newValueToInsertInToSymTable,null,null,getIndentation(),null));
                                            
                                                    
                                            }else if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN") || splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")){
                                                    
                                                    //non posso dire nulla si che tipo di operazione si tratta
                                                    //devo vedere cosa e' contenuto dentro lastParameters
                                            	
                                            	String isSUM = UtilsToSymTable.isSumTuplaOrGenericList(parameters.get(i),lastParameters, splitStringBuilder, getIndentation(), parser.symTable, parser.ereditClassToFunctionInvocation);
                                            	if(!isSUM.equals("ERROR")){
                                            		sb.append(isSUM);
                                            	}
                                            	else{
                                            	String lenFunction = isLEN(lastParameters, getIndentation());
                                        		if(lenFunction!=null){
                                        			//sicuro ho una la funzione LEN
                                        			//System.out.println("LEN-FUNCTION: "+ lenFunction);

                                        			if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                        				
                                        				boolean flag = UtilsToSymTable.isExist(lastParameters, getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                        				sb.append(tab);
                                        				if(!flag)
                                        					sb.append("Object ");
                                        				//sb.append(parameters.get(i));
                                        				//parameters_with_self
                                        				sb.append(parameters_with_self.get(i));
                                        				sb.append(" = ");
                                        				sb.append(lenFunction);
                                        				sb.append(";\n");
                                        				
                                                        SymbolType symbol=new SymbolType(parameters.get(i),"Integer","0",null,null,getIndentation(),null);
                                                        parser.symTable.putSymbol(getIndentation(),parameters.get(i),symbol);
	                                                }else{
                                                        //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
                                                        String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                        
                                                        boolean flag = UtilsToSymTable.isExist(newNameVariable, getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                        sb.append(tab);
                                                        if(!flag)
                                        					sb.append("Object ");
                                        				ArrayList<String> arraySenzaPunti = UtilsToSymTable.tokenParameters(parameters.get(i),".");
                                        				String parameterSX = getStringBuilderForStringWithPoint(arraySenzaPunti.get(0), arraySenzaPunti.get(1), getIndentation());
                                        				//System.out.println("isLEN: parameterSX: " + parameterSX);
                                        				sb.append(parameterSX);
                                        				sb.append(" = ");
                                        				sb.append(lenFunction);
                                        				sb.append(";\n");
                                        				
                                                        SymbolType symbol=new SymbolType(parameters.get(i),"Integer","0",null,null,getIndentation(),null);
                                                        parser.symTable.putSymbol(getIndentation(),newNameVariable,symbol);
	                                                }

                                        		
                                        		}else{

                                                    ArrayList<String> arrayLP = UtilsToSymTable.tokenParameters(lastParameters,"+\\-*/\\^&\\|;<>=%");
                                                    
                                                    ArrayList<String> arrayLP_with_self = UtilsToSymTable.tokenParameters(parameters_with_self.get(parameters_with_self.size()-1),"+\\-*/\\^&\\|;<>=%");
                                                    
                                                    //UtilsToSymTable.printArrayList(arrayLP, "arrayLP");
                                                    
                                                    boolean isNegativeTupListDict = UtilsToSymTable.isSubTupLisDictNEGATIVEindex(lastParameters,getIndentation(), parser.symTable, parser.ereditClassToFunctionInvocation);
                                                    
                                                    if(arrayLP.size()>1 && !isNegativeTupListDict){
                                                            //abbiamo a che fare con una espressione

                                                            ArrayList<String> arrayOperator= getOperator(arrayLP, lastParameters);
                                                    
                                                            StringBuilder sb7 = new StringBuilder();
                                                            
                                                            boolean vaiAvanti = true;
                                                            
                                                            for(int w = 0; w<arrayLP.size(); w++){
                                                                    
                                                                    String ty = CheckType.check(arrayLP.get(w));
                                                                    
                                                                    if(ty.equals("Object")){
                                                                            String typeOfObject = UtilsToSymTable.getVariableType(arrayLP.get(w),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                            if(typeOfObject!=null){
                                                                                    if(!typeOfObject.equals("PDictionary")){
                                                                                            String value = UtilsToSymTable.getValue(arrayLP.get(w),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                            if(value==null){
                                                                                                    sb7.append(arrayLP.get(w));
                                                                                                    if(w!=arrayOperator.size()){
                                                                                                            sb7.append(arrayOperator.get(w));
                                                                                                    }
                                                                                            }else{
                                                                                                    sb7.append(value);
                                                                                                    if(w!=arrayOperator.size()){
                                                                                                            sb7.append(arrayOperator.get(w));
                                                                                                    }
                                                                                            }
                                                                                    }else{
                                                                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION: e' un PDictionary\n");
                                                                                            //break;
                                                                                    }
                                                                            }else{
                                                                                    //qui ho typeOfObject == null
                                                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION: TYPE OBJECT NULL\n");
                                                                                    vaiAvanti = false;
                                                                            }
                                                                    }
                                                                    else{
                                                                            sb7.append(arrayLP.get(w));
                                                                            if(w!=arrayOperator.size()){
                                                                                    sb7.append(arrayOperator.get(w));
                                                                            }
                                                                    }
                                                            }
                                                            
                                                            //System.out.println("--------StringBuilder7: "+sb7.toString());
                                                            
                                                            if(sb7.toString().contains(",") && vaiAvanti==true){
	                                                            	String tmpSB7 = sb7.toString().replace("\"","\\\"");
	                                                        		sb7.delete(0,sb7.length());
	                                                        		sb7.append(tmpSB7);
                                                                    if(sb7.toString().contains("[") && sb7.toString().contains("]")){
                                                                            //sicuro generic list
                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                    //parameters_with_self
                                                                            		StringBuilder sb8 = getStringBuilderResultOperationTuplaOrGenericList("GenericList",parameters_with_self.get(i),sb7.toString(),getIndentation()); 
                                                                                
                                                                            		//System.out.println("--------StringBuilder8: "+sb8.toString());
                                                                            		sb.append(tab);
                                                                            		sb.append(sb8.toString());
                                                                                    
                                                                                    String newValue = UtilsToSymTable.getValueModels("resultOperationsGenericList",null,sb7.toString(),null,-1, parser.getSymbolTable());
                                                                                    
                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),"GenericList",newValue,null,null,getIndentation(),null));
                                                                            }else{
                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT") 
                                                                                    //es: ((nomeClasse)p).attr
                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                    sb.append(tab);
                                                                                    sb.append(parameterSX);
                                                                                    sb.append(" = ");
                                                                                    sb.append("new GenericList();\n");
                                                                                    sb.append(tab);
                                                                                    sb.append("((GenericList)" + parameterSX +").resultOperationsGenericList(\""+sb7.toString()+"\");\n");
                                                                                    
                                                                                    String newValue = UtilsToSymTable.getValueModels("resultOperationsGenericList",null,sb7.toString(),null,-1, parser.getSymbolTable());
                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),"GenericList",newValue,null,null,getIndentation(),null));
                                                                                    
                                                                            }
                                                                            
                                                                    }else{
                                                                            //sicuro tupla
                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                            		//parameters_with_self
                                                                            		//StringBuilder sb8 = getStringBuilderResultOperationTuplaOrGenericList("Tupla",parameters.get(i),sb7.toString(),getIndentation());
                                                                            		StringBuilder sb8 = getStringBuilderResultOperationTuplaOrGenericList("Tupla",parameters_with_self.get(i),sb7.toString(),getIndentation());
                                                                                    
                                                                            		//System.out.println("--------StringBuilder8: "+sb8.toString());
                                                                            		sb.append(tab);
                                                                            		sb.append(sb8.toString());
                                                                                    
                                                                                    String newValue = UtilsToSymTable.getValueModels("resultOperationsTupla",null,sb7.toString(),null,-1, parser.getSymbolTable());
                                                                                    
                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),"Tupla",newValue,null,null,getIndentation(),null));
                                                                            }else{
                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT") 
                                                                                    //es: ((nomeClasse)p).attr
                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                    sb.append(tab);
                                                                                    sb.append(parameterSX);
                                                                                    sb.append(" = ");
                                                                                    sb.append("new Tupla();\n");
                                                                                    sb.append(tab);
                                                                                    sb.append("((Tupla)" + parameterSX +").resultOperationsTupla(\""+sb7.toString()+"\");\n");
                                                                                    
                                                                                    String newValue = UtilsToSymTable.getValueModels("resultOperationsTupla",null,sb7.toString(),null,-1, parser.getSymbolTable());
                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),"Tupla",newValue,null,null,getIndentation(),null));
                                                                            
                                                                            }
                                                                    }
                                                                            
                                                            }else if(vaiAvanti==true){
                                                                    //verificare che sono tutti dello stesso tipo!
                                                                    ArrayList<String> arrayFromSb7 = UtilsToSymTable.tokenParameters(sb7.toString(),"+\\-*/\\^&\\|;<>=%");
                                                                    //UtilsToSymTable.printArrayList(arrayFromSb7, "arrayFromSb7");
                                                                    
                                                                    ArrayList<String> arrayOperator2 = getOperator(arrayFromSb7,sb7.toString());
                                                                    //UtilsToSymTable.printArrayList(arrayOperator2, "arrayOperator2");
                                                                    
                                                                    String ty_pe = null;
                                                                    
                                                                    boolean thereIsAnObject = false;
                                                                    
                                                                    for(int u = 0; u<arrayFromSb7.size(); u++){
                                                                    
                                                                            //System.out.println("arrayFromSb7.get(u):"+ arrayFromSb7.get(u));
                                                                            
                                                                            String ty = CheckType.check(arrayFromSb7.get(u));
                                                                            //System.out.println("ty: " + ty);
                                                                            
                                                                            
                                                                            if(ty.equals("Object")){
                                                                                    String objectValue = UtilsToSymTable.getVariableType(arrayFromSb7.get(u),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                    //System.out.println("objectValue = "+objectValue);
                                                                                    if(objectValue!=null && !objectValue.equals("Object")){
                                                                                            if(!objectValue.equals(ty_pe) && ty_pe!=null){
                                                                                                    ty_pe = "ERROR";
                                                                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION: con Object\n");
                                                                                                    //break;
                                                                                            }else{
                                                                                                    ty_pe = objectValue;
                                                                                            }
                                                                                    }else{
                                                                                            //objectValue == null -> perch� ad esempio
                                                                                            //in lastParameters c'� una variabile che ha come valore
                                                                                            //il tipo di ritorno di una funzione oppure � la variabile
                                                                                            //che compare come argomento della funzione stessa.
                                                                                            //es:
                                                                                            //1) x = ff(w,p) -> e sotto -> y = x + 1
                                                                                            //2) func(x):..... -> e dentro la funzione: y = x + 1
                                                                                                                                                                                    
                                                                                            //setto il flag a true
                                                                                            //System.out.println("thereIsAnObject = true");
                                                                                            thereIsAnObject = true;
                                                                                    
                                                                                    }
                                                                                    
                                                                            }else{
                                                                                    if(!ty.equals(ty_pe) && ty_pe!=null){
                                                                                    	if( (ty.equals("Integer") && (ty_pe.equals("Double") || ty_pe.equals("Float"))) || (ty_pe.equals("Integer") && (ty.equals("Double") || ty.equals("Float"))) ){
	                                                                            			//System.out.println(" TUTTO E' DA CASTARE A DOUBLE/FLOAT ");
	                                                                            			ty_pe = "Double"; //or Float?
	                                                                            		}else{
                                                                                            ty_pe = "ERROR";
                                                                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION: senza Object - uffa\n");
	                                                                            		}
                                                                                    }else{
                                                                                            ty_pe = ty;
                                                                                    }
                                                                            }

                                                                    }
                                                                    

                                                                    if(!ty_pe.equals("ERROR")){
                                                                    		
                                                                            StringBuilder parameterDX = new StringBuilder();
                                                                            if(thereIsAnObject==true){
                                                                                    //System.out.println("EBBENE SI -> HO OBJECT IN LASTPARAMETERS");
                                                                                    //se sono qui -> nella parte DX (cio� in lastParameters) ho un Object con value = null
                                                                                    //devo allora fare il cast a ty_pe
                                                                                    for(int r = 0; r<arrayLP.size(); r++){
                                                                                            String ty = CheckType.check(arrayLP.get(r));
                                                                                            if(ty.equals("Object")){
                                                                                                    //String objectValue = UtilsToSymTable.getVariableType(arrayLP.get(r),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                            		parameterDX.append(UtilsToSymTable.getStringBuilderToAssignamentWithExpression(arrayLP_with_self.get(r),ty_pe));
                                                                                            		if(r!=arrayOperator.size()){
                                                                                                            parameterDX.append(arrayOperator.get(r));
                                                                                                    }
                                                                                            }else{
                                                                                                    //caso in cui: if(!ty.equals("Object"))
                                                                                                    //parameterDX.append(arrayLP.get(r));
                                                                                            		parameterDX.append(arrayLP_with_self.get(r));
                                                                                                    if(r!=arrayOperator.size()){
                                                                                                            parameterDX.append(arrayOperator.get(r));
                                                                                                    }
                                                                                            }
                                                                                    }
                                                                            }else{
                                                                                    //System.out.println("NON HO OBJECT IN LASTPARAMETERS");
                                                                                    
                                                                                    for(int r = 0; r<arrayLP.size(); r++){
                                                                                            String ty = CheckType.check(arrayLP.get(r));
                                                                                            if(ty.equals("Object")){
                                                                                                    parameterDX.append("(("+ty_pe+")"+arrayLP_with_self.get(r)+")");
                                                                                                    if(r!=arrayOperator.size()){
                                                                                                            parameterDX.append(arrayOperator.get(r));
                                                                                                    }
                                                                                            }else{
                                                                                                    //parameterDX.append(arrayLP.get(r));
                                                                                                    parameterDX.append(arrayLP_with_self.get(r));
                                                                                                    if(r!=arrayOperator.size()){
                                                                                                            parameterDX.append(arrayOperator.get(r));
                                                                                                    }
                                                                                            }
                                                                                    }

                                                                                    //parameterDX.append(lastParameters);
                                                                            }
                                                                    
                                                                            //INSERISCO CODICE:
                                                                    
                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                    boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                                    
                                                                                    sb.append(tab);
                                                                                    if(flag==false)
                                                                                            sb.append("Object ");
                                                                                    
                                                                                    //sb.append(parameters.get(i));
                                                                                    sb.append(parameters_with_self.get(i));
                                                                                    sb.append(" = ");
                                                                                    sb.append(parameterDX.toString());
                                                                                    sb.append(";\n");
                                                                                    
                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),ty_pe,lastParameters,null,null,getIndentation(),null));
                                                                            
                                                                            }else{
                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT") 
                                                                                    //es: ((nomeClasse)p).attr
                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                    sb.append(tab);
                                                                                    sb.append(parameterSX);
                                                                                    sb.append(" = ");
                                                                                    sb.append(parameterDX.toString());
                                                                                    sb.append(";\n");
                                                                                    
                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),ty_pe,lastParameters,null,null,getIndentation(),null));
                                                                            }
                                                                    }
                                                                    
                                                            }
                                                            

                                                            
                                                    }else{
                                                            //abbiamo una singola assegnazione
                                                            
                                                            String typeLastParameters = CheckType.check(lastParameters);
                                                            
                                                            //System.out.println("typeLastParameters: "+typeLastParameters);
                                                            
                                                            if(typeLastParameters.equals("Object")){
                                                                    //vediamo che tipo ha la variabile

                                                            
                                                                    String ty_pe = UtilsToSymTable.getVariableType(lastParameters,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                    
                                                                    //System.out.println("ty_pe per Object: "+ty_pe);
                                                                    
                                                                    if(ty_pe!=null){
                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                    //StringBuilder sb3 = getStringBuilderAssignament("Object",lastParameters,parameters.get(i),getIndentation());
                                                                            		StringBuilder sb3 = getStringBuilderAssignament("Object",parameters_with_self.get(parameters_with_self.size()-1),parameters_with_self.get(i),getIndentation());
                                                                            		sb.append(tab);
                                                                            		sb.append(sb3.toString());
                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),ty_pe,lastParameters,null,null,getIndentation(),null));
                                                                            }
                                                                            else{
                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                    sb.append(tab);
                                                                                    sb.append(parameterSX);
                                                                                    sb.append(" = ");
                                                                                    //sb.append(lastParameters);
                                                                                    sb.append(parameters_with_self.get(parameters_with_self.size()-1));
                                                                                    sb.append(";\n");
                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),ty_pe,lastParameters,null,null,getIndentation(),null));
                                                                            }
                                                                            
                                                                    }else{
                                                                            //la variabile non esiste
                                                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION: AUTO GENERATE CODE\n");
                                                                    }
                                                                    

                                                                    
                                                            }else if(typeLastParameters.equals("String")){
                                                                    //se ci sono " oppure ' -> Stringa vera!
                                                                    //casi possibili:
                                                                    //1) d = p.attr
                                                                    //2) Normale Stringa
                                                                    //3) c = g[1:2] oppure c = g[4]
                                                                    //4) h = p.func()
                                                                    
                                                                    //arrayWithoutPoint.get(0) = variabile (se c'e'), oppure direttamente funzione
                                                            		String whithoutPointInsideParents = UtilsToSymTable.replaceCharInsideParents(lastParameters,'.');
                                                                    ArrayList<String> arrayWithoutPoint = UtilsToSymTable.tokenParameters(whithoutPointInsideParents,".");
                                                                    //UtilsToSymTable.printArrayList(arrayWithoutPoint,"arrayWithoutPoint - ASSIGNAMENT");
                                                                    
                                                                    if(arrayWithoutPoint.size()>1){
                                                                            //siamo nei seguenti due casi:
                                                                            // d = p.attr
                                                                            // h = p.func(...)
                                                                            
                                                                            //System.out.println("SENZA APICI MA CON PUNTI (No Quotes / Yes Points)");
                                                                            
                                                                            //array.get(0) = nome funzione invocata (al 100%)
                                                                            //array.get(1) = lista dei paramentri passati alla funzione (potrebbe non esistere, se non passo nulla)
                                                                            ArrayList<String> array=UtilsToSymTable.tokenParameters(arrayWithoutPoint.get(arrayWithoutPoint.size()-1),"()");
                                                                            
                                                                            int numFunctionParam = 0;
                                                                            if(array.size()>1){
                                                                                    ArrayList<String> params = UtilsToSymTable.tokenParameters(array.get(1),",");
                                                                                    numFunctionParam = params.size();
                                                                            }
                                                                            
                                                                            String className2 = new String();
                                                                            //vedo se arrayWithoutPoint.get(0) e' una variabile
                                                                            boolean isAVariable = UtilsToSymTable.isExist(arrayWithoutPoint.get(0),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                            //System.out.println("UtilsToSymTable.isExist");
                                                                            if(isAVariable==true){
                                                                            		//System.out.println("className2: "+className2);
                                                                                    className2 = UtilsToSymTable.getVariableType(arrayWithoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                            }else{
                                                                                    className2 = "DefaultClass";
                                                                            }
                                                                            
                                                                            boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),className2, getIndentation(),parser.getSymbolTable());
                                                                            
                                                                            String tf = UtilsToSymTable.getVariableType(arrayWithoutPoint.get(0),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                            if(!funcOK && tf!=null){
                                                                            	if(tf.equals("Object")){
                                                                            	String toSearch = array.get(0)+"#"+String.valueOf(numFunctionParam);
                                                                            	//System.out.println("toSearch: " +toSearch);
                                                                            	className2 = UtilsToSymTable.getClassNameOfFunction(toSearch,getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                            	//System.out.println("className2: " +className2);
                                                                            	if(className2!=null);
                                                                            		funcOK = true;
                                                                            	}
                                                                            }
                                                                            
                                                                            if(funcOK){
                                                                            		boolean hasReturn = UtilsToSymTable.functionHasReturn(array.get(0),String.valueOf(numFunctionParam),className2, getIndentation(), parser.getSymbolTable());
                                                                            		
                                                                            		if(hasReturn){
                                                                            			boolean isOKOK = true;
                                                                            			if(array.size()>1){
                                                                            				isOKOK = UtilsToSymTable.isCorrectListOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                            			}
                                                                            			
                                                                            			
                                                                            			if(isOKOK){
                                                                            				//System.out.println("funcOK____ TRUE");
    	                                                                                    boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
    	                                                                                    if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
    	                                                                                    		sb.append(tab);
    	                                                                                    		if(flag==false)
    	                                                                                                    sb.append("Object ");
    	                                                                                            sb.append(parameters.get(i));
    	                                                                                    }else{
    	                                                                                            String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
    	                                                                                            sb.append(tab);
    	                                                                                            sb.append(parameterSX);
    	                                                                                    }
    	                                                                                    
    	                                                                                    sb.append(" = ");
    	                                     /*                                               
    	                                                                                    if(arrayWithoutPoint.size()>1){
    	                                                                                            sb.append("(("+className2+")"+arrayWithoutPoint.get(0)+")."+arrayWithoutPoint.get(1)+";\n");
    	                                                                                    }
    	                                                                                    else{
    	                                                                                            sb.append("DefaultClass."+lastParameters+";\n");
    	                                                                                    }
    	                                   */                                                 
    	                                                                                    
    	                                                                                    if(className2.equals("DefaultClass")){
    	                                                                                    	sb.append("DefaultClass."+array.get(0));
    	                                                                                    	sb.append("(");
    	                                                                                    	String args = "";
    	                                                                                    	if(array.size()>1){
    	                                                                                    		args = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
    	                                                                                    	}
    	                                                                                    	sb.append(args);
    	                                                                                    	sb.append(")");
    	                                                                                    	sb.append(";\n");
    	                                                                                    }
    	                                                                                    else{
                                                                                                sb.append("(("+className2+")"+arrayWithoutPoint.get(0)+")."+array.get(0));
                                                                                                sb.append("(");
    	                                                                                    	String args = "";
    	                                                                                    	if(array.size()>1){
    	                                                                                    			args = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
    	                                                                                    	}
    	                                                                                    	sb.append(args);
    	                                                                                    	sb.append(")");
    	                                                                                    	sb.append(";\n");
    	                                                                                    }
    	                                                                                    
    	                                                                                    if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
    	                                                                                            SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
    	                                                                                            parser.symTable.putSymbol(getIndentation(),parameters.get(i),symbol);
    	                                                                                    }else{
    	                                                                                            //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
    	                                                                                            String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
    	                                                                                            SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
    	                                                                                            parser.symTable.putSymbol(getIndentation(),newNameVariable,symbol);
    	                                                                                    }	
                                                                            			}
                                                                            			else
                                                                            				sb.append(tab+"//ERROR into Assignament - Argoments of method invocated aren't correct\n");
                                                                            		}else{
                                                                            			sb.append(tab+"//ERROR into Assignament - The method has not return value\n");
                                                                            		}
                                                                                    
                                                                            }else{
                                                                                    
                                                                                    //caso:  p.attr#nomeClasse
                                                                                    
                                                                                    String classe  = UtilsToSymTable.getVariableType(arrayWithoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                    
                                                                                    if(classe!=null){
                                                                                            String varibleToSearch =  arrayWithoutPoint.get(0)+"."+ arrayWithoutPoint.get(1) +"#"+ classe;
                                                                                            //System.out.println("varibleToSearch: "+ varibleToSearch);
                                                                                            
                                                                                            String typeVaribleToSearchs = UtilsToSymTable.getVariableType(varibleToSearch,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                            String valueVaribleToSearchs = UtilsToSymTable.getValue(varibleToSearch,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                            
                                                                                            if(typeVaribleToSearchs!=null){
                                                                                                    
                                                                                                    String parameterDX = "(("+classe+")"+arrayWithoutPoint.get(0)+")."+arrayWithoutPoint.get(1);

                                                                                                    if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                                            boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                                                            sb.append(tab);
                                                                                                            if(flag==false)
                                                                                                                    sb.append("Object ");
                                                                                                            sb.append(parameters.get(i));
                                                                                                            sb.append(" = ");
                                                                                                            sb.append(parameterDX);
                                                                                                            sb.append(";\n");
                                                                                                            
                                                                                                            SymbolType symbol=new SymbolType(parameters.get(i),typeVaribleToSearchs,valueVaribleToSearchs,null,null,getIndentation(),null);
                                                                                                            parser.symTable.putSymbol(getIndentation(),parameters.get(i),symbol);
                                                                                                    }else{
                                                                                                            //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
                                                                                                            
                                                                                                            //gestione parametro di DX --> che a sua volta � del tipo d.attr
                                                                                                            ArrayList<String> arrayWithoutPointParameterSX = UtilsToSymTable.tokenParameters(parameters.get(i),".");
                                                                                                            String classeNameParameterSX = UtilsToSymTable.getVariableType(arrayWithoutPointParameterSX.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                                            
                                                                                                            if(classeNameParameterSX!=null){
                                                                                                                    String parameterSX = "(("+classeNameParameterSX+")"+arrayWithoutPointParameterSX.get(0)+")."+arrayWithoutPointParameterSX.get(1);
                                                                                                                    //System.out.println("parameterDX (caso DOPPIO): " + parameterSX );
                                                                                                                    
                                                                                                                    sb.append(tab);
                                                                                                                    sb.append(parameterSX);
                                                                                                                    sb.append(" = ");
                                                                                                                    sb.append(parameterDX);
                                                                                                                    sb.append(";\n");
                                                                                                                    
                                                                                                                    String newNameVariable = parameters.get(i)+"#"+classeNameParameterSX;
                                                                                                                    SymbolType symbol=new SymbolType(parameters.get(i),typeVaribleToSearchs,valueVaribleToSearchs,null,null,getIndentation(),null);
                                                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable,symbol);
                                                                                                            }else{
                                                                                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION_1: Right Variable Not Defined\n");
                                                                                                            }
                                                                                                    }       
                                                                                                    
                                                                                                    
                                                                                            }else{
                                                                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION_2: Right Variable Not Defined\n");
                                                                                            }
                                                                                            
                                                                                    }else{
                                                                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION_3: Right Variable Not Defined\n");
                                                                                    }
                                                                            }
                                                                            
                                                                    
                                                                    }else if(lastParameters.contains("(") && lastParameters.contains(")")){
                                                                    	//System.out.println("FUNZIONE DENTRO LA STESSA CLASSE! ");                         	
                                                                    	 
                                                                    	 String args_con_cancelletto_dentro_parentesi = UtilsToSymTable.replaceCharInsideParents(lastParameters,'.');
                                                                    	 ArrayList<String> array=UtilsToSymTable.tokenParameters(args_con_cancelletto_dentro_parentesi,"();");
                                                                    	 //UtilsToSymTable.printArrayList(array, "array - FUNZIONE DENTRO LA STESSA CLASSE");
                                                                         int numFunctionParam = 0;
                                                                         if(array.size()>1){
                                                                                 ArrayList<String> params = UtilsToSymTable.tokenParameters(array.get(1),",");
                                                                                 numFunctionParam = params.size();
                                                                         }
                                                                         //System.out.println("numFunctionParam: "+numFunctionParam);
                                                                         String className2 = null;
                                                                         //cerco nello stella stessa classe
											                             boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),null, getIndentation(),parser.getSymbolTable());
											                             if(!funcOK){
											                            	 //cerco tra le classi ereditate
											                            	 int caught = -1;
											                            	 if(parser.ereditClassToFunctionInvocation.size()!=0){
												         						for(int qw=0; qw<parser.ereditClassToFunctionInvocation.size(); qw++){
												         							funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),parser.ereditClassToFunctionInvocation.get(qw), getIndentation(),parser.getSymbolTable());
												                                    if(funcOK)
												                                    	caught = qw;
												         						}
												                             }
											                            	 if(caught!=-1){
											                            		className2 = parser.ereditClassToFunctionInvocation.get(caught); 
											                                 	//System.out.println("parser.ereditClassToFunctionInvocation - first: " + className2);
											                            	 }else {
											                            		 //cerco nella classe di default
											                            		funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),"DefaultClass", getIndentation(),parser.getSymbolTable());
											                            		if(funcOK)
											                            			className2 = "DefaultClass";
											                            	 }
											                             }
											                          /*   
											                             boolean funcOK = false;
                                                                         if(parser.ereditClassToFunctionInvocation.size()!=0){
                                                     						UtilsToSymTable.printArrayList(parser.ereditClassToFunctionInvocation, "ereditClassToFunctionInvocation");
                                                     						for(int qw=0; qw<parser.ereditClassToFunctionInvocation.size(); qw++){
                                                     							funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),parser.ereditClassToFunctionInvocation.get(qw), getIndentation(),parser.getSymbolTable());
                                                                                if(funcOK){
                                                                                	className2 = parser.ereditClassToFunctionInvocation.get(qw); 
                                                                                	System.out.println("parser.ereditClassToFunctionInvocation.get(qw)" + className2);
                                                                                	break;
                                                                                }
                                                     						}
                                                                         }else{
                                                                            funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),null, getIndentation(),parser.getSymbolTable());
                                                                         }
                                                                         */

                                                                                                                                                  
                                                                         if(funcOK){
                                                                     		if(UtilsToSymTable.functionHasReturn(array.get(0),String.valueOf(numFunctionParam),className2, getIndentation(), parser.getSymbolTable())){
 	                                                                            boolean isOKOK = true;
 	                                                                            if(array.size()>1){
 	                                                                        	   isOKOK = UtilsToSymTable.isCorrectListOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
 	                                                                            }
                                                                     			if(isOKOK){
	                                                                     			boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	 	                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
	 	                                                                            		sb.append(tab);
	 	                                                                                    if(flag==false)
	 	                                                                                            sb.append("Object ");
	 	                                                                                    sb.append(parameters_with_self.get(i));
	 	                                                                            }else{
	 	                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
	 	                                                                                    sb.append(tab);
	 	                                                                                    sb.append(parameterSX);
	 	                                                                            }
	 	                                                                            
	 	                                                                            sb.append(" = ");
	 	                                                                            sb.append(array.get(0));
	                                                                               	sb.append("(");
	                                                                               	String args = "";
	                                                                                if(array.size()>1){
	                                                                                	args = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	                                                                                }
	                                                                               	sb.append(args);
	                                                                               	sb.append(")");
	                                                                               	sb.append(";\n");
	 	                                                                                                            
	 	                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
	 	                                                                                    SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
	 	                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i),symbol);
	 	                                                                            }else{
	 	                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
	 	                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
	 	                                                                                    SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
	 	                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable,symbol);
	 	                                                                            }
 	                                                                            }
 	                                                                            else
 	                                                                            	sb.append(tab+"//ERROR into Assignament - Parameters of functions have errors! \n");
 	                                                                            
                                                                     		}else{
                                                                     			sb.append(tab+"//ERROR into Assignament_1 - The method invocated "+ lastParameters +" has not return value\n");
                                                                     		}
                                                                             
                                                                     }else{
                                                                    	 sb.append(tab+"//ERROR into Assignament_2 - The method invocated "+ lastParameters +" has not exist\n");
                                                                     }
                                                                         
                                                                         
                                                                    }else if(lastParameters.contains("[") || lastParameters.contains("]")){
                                                                            //siamo nei seguenti due casi:
                                                                            // c = g[4]
                                                                            // c = g[1:2]
                                                                            
                                                                            //System.out.println("SENZA APICI NE PUNTI (No Quotes / No Points)");
                                                                                    
                                                                            ArrayList<String> arrayWhithoutBrackets = UtilsToSymTable.tokenParameters(lastParameters,"[]");
                                                                            //UtilsToSymTable.printArrayList(arrayWhithoutBrackets, "arrayWhithoutBrackets");
                                                                            
                                                                            String typeWhithoutBrackets = UtilsToSymTable.getVariableType(arrayWhithoutBrackets.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                            //System.out.println("typeWhithoutBrackets: "+ typeWhithoutBrackets + " indentazione attuale: " + getIndentation());
                                                                            
                                                                            if(typeWhithoutBrackets!=null){
                                                                                    if(typeWhithoutBrackets.equals("Tupla") || typeWhithoutBrackets.equals("GenericList")){
                                                                                            
                                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                            		String type_dentro = CheckType.check(arrayWhithoutBrackets.get(1));
                                                                                            		if(type_dentro.equals("Object")){
                                                                                            			String resultToStamp = WhileIfCondition.getStringBuilderSingleCondition(lastParameters,"TupListDict","",getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                            			//System.out.println("resultToStamp: "+resultToStamp);
                                                                                            			boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                                		if(flag==false){
                                                                                                			sb.append(tab);
                                                                                                			sb.append("Object ");
                                                                                                			sb.append(parameters.get(i));
                                                                                                			sb.append(" = new ");
                                                                                                			sb.append(typeWhithoutBrackets);
                                                                                                			sb.append("();\n");
                                                                                                		}
                                                                                                		sb.append(tab);
                                                                                                		sb.append(parameters.get(i));
                                                                                                		sb.append(" = ");
                                                                                                		sb.append(resultToStamp);
                                                                                                		sb.append(";\n");
                                                                                                		
                                                                                                		//insert into SymTable:
                                                                                                		String val = UtilsToSymTable.getValue(arrayWhithoutBrackets.get(1),getIndentation(), parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                                		String newValues = UtilsToSymTable.getValueModels("sub"+typeWhithoutBrackets,null,val,arrayWhithoutBrackets.get(0),getIndentation(), parser.getSymbolTable());
                                                                                                		//System.out.println("newValues: "+newValues);
                                                                                                		ArrayList<String> senzaDuePunti = UtilsToSymTable.tokenParameters(arrayWhithoutBrackets.get(1),":");
                                                                                                		//UtilsToSymTable.printArrayList(senzaDuePunti, "senzaDuePunti");
                                                                                                		String newType = typeWhithoutBrackets;
                                                                                            			if(senzaDuePunti.size()==1){
                                                                                            				newValues = newValues.replace("[","");
                                                                                            				newValues = newValues.replace("]","");
                                                                                            				//System.out.println("newValues: "+newValues);
                                                                                            				newType = CheckType.check(newValues);
                                                                                            				//System.out.println("newType: "+newType);
                                                                                            			}
                                                                                                		
                                                                                                		parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),newType,newValues,null,null,getIndentation(),null));
                                                                                                		
                                                                                            		}else{
	                                                                                                    ArrayList<String> subString = UtilsToSymTable.tokenParameters(lastParameters,arrayWhithoutBrackets.get(0));
	                                                                                                    //UtilsToSymTable.printArrayList(subString, "subString");
	                                                                                                    StringBuilder sb4 = getStringBuilderSubTuplaOrGenericList(typeWhithoutBrackets,arrayWhithoutBrackets.get(0),parameters.get(i),subString.get(0),getIndentation());
	                                                                                                    sb.append(tab);
	                                                                                                    sb.append(sb4.toString());
	                                                                                                    String newValues = UtilsToSymTable.getValueModels("sub"+typeWhithoutBrackets,null,subString.get(0),arrayWhithoutBrackets.get(0),getIndentation(), parser.getSymbolTable());
	                                                                                                    
	                                                                                                    ArrayList<String> senzaDuePunti = UtilsToSymTable.tokenParameters(arrayWhithoutBrackets.get(1),":");
                                                                                                		//UtilsToSymTable.printArrayList(senzaDuePunti, "senzaDuePunti");
                                                                                                		String newType = typeWhithoutBrackets;
                                                                                            			if(senzaDuePunti.size()==1){
                                                                                            				//System.out.println("newValues: "+newValues);
                                                                                            				newValues = newValues.replace("[","");
                                                                                            				newValues = newValues.replace("]","");
                                                                                            				newType = CheckType.check(newValues);
                                                                                            				//System.out.println("newType: "+newType);
                                                                                            			}
	                                                                                                    
	                                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),newType,newValues,null,null,getIndentation(),null));
                                                                                            		}
                                                                                            }else{
                                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT") 
                                                                                                    //es: ((nomeClasse)p).attr
                                                                                                    ArrayList<String> subString = UtilsToSymTable.tokenParameters(lastParameters,arrayWhithoutBrackets.get(0));
                                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                                    sb.append(tab);
                                                                                                    sb.append(parameterSX);
                                                                                                    sb.append(" = ");
                                                                                                    sb.append("new "+typeWhithoutBrackets+"();\n");
                                                                                                    
                                                                                                    sb.append(tab);
                                                                                                    sb.append(parameterSX);
                                                                                                    sb.append(" = ");
                                                                                                    sb.append("(("+typeWhithoutBrackets+")" + arrayWhithoutBrackets.get(0) +").sub"+typeWhithoutBrackets+"(\""+subString.get(0)+"\");\n");
                                                                                                    
                                                                                                    String newValues = UtilsToSymTable.getValueModels("sub"+typeWhithoutBrackets,null,subString.get(0),arrayWhithoutBrackets.get(0),getIndentation(), parser.getSymbolTable());
                                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),typeWhithoutBrackets,newValues,null,null,getIndentation(),null));
                                                                                                    
                                                                                            }                               
                                                                                            
                                                                                    }else if(typeWhithoutBrackets.equals("PDictionary")){
                                                                                            //System.out.println("SINGOLO ELEMENTO DIZIONARIO");
                                                                                            String type_dentro = CheckType.check(arrayWhithoutBrackets.get(1));
                                                                                            String resultToStamp = arrayWhithoutBrackets.get(1);
                                                                                    		if(type_dentro.equals("String")){
                                                                                    			resultToStamp = "\"\\\""+arrayWhithoutBrackets.get(1).replace("\"","")+"\\\"\"";
                                                                                    		}
                                                                                    		
                                                                                    		boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                                    		sb.append(tab);
                                                                                    		if(flag==false){
                                                                                    			sb.append("Object ");
                                                                                    		}
                                                                                    		sb.append(parameters.get(i));
                                                                                    		sb.append(" = ");
                                                                                    		sb.append("((PDictionary)"+arrayWhithoutBrackets.get(0)+").getSigleValue("+resultToStamp+");\n");
                                                                                            
                                                                                    		//Insert into SymTAble
                                                                                    		String newValues = UtilsToSymTable.getValueModels("getSigleValue",null,arrayWhithoutBrackets.get(1),arrayWhithoutBrackets.get(0),getIndentation(), parser.getSymbolTable());
                                                                                            //System.out.println("newValues - dic: " +newValues);
                                                                                    		String typeOfVariable = CheckType.check(newValues);
                                                                                    		//System.out.println("typeOfVariable - dic: " +typeOfVariable);
                                                                                    		parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),typeOfVariable,newValues,null,null,getIndentation(),null));
                                                                                            
                                                                                    }else {
                                                                                        sb.append(tab+"//ERROR IN VARIABLE DEFINITION\n");
                                                                                    }
                                                                            }else{
                                                                                    sb.append(tab+"//ERROR IN VARIABLE DEFINITION\n");
                                                                            }
                                                                    }else{
                                                                        //sicuro Stringa
                                                                        
                                                                        //System.out.println("CONTENGO GLI APICI (Quotes)");
                                                                        
                                                                        if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                //parameters.get(parameters.size()-1)
                                                                        		//StringBuilder sb5 = getStringBuilderAssignament(typeLastParameters,lastParameters,parameters.get(i),getIndentation());
                                                                        		StringBuilder sb5 = getStringBuilderAssignament(typeLastParameters,parameters_with_self.get(parameters_with_self.size()-1),parameters_with_self.get(i),getIndentation());
                                                                        		sb.append(tab);
                                                                        		sb.append(sb5.toString());
                                                                                parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),typeLastParameters,lastParameters,null,null,getIndentation(),null));
                                                                        }else{
                                                                                //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
                                                                                String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                sb.append(tab);
                                                                                sb.append(parameterSX);
                                                                                //sb.append(getDXAssignament(typeLastParameters,lastParameters));
                                                                                sb.append(getDXAssignament(typeLastParameters,parameters_with_self.get(parameters_with_self.size()-1)));
                                                                                String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),typeLastParameters,lastParameters,null,null,getIndentation(),null));
                                                                        }
                                                                    }


                                                                    
                                                            }else{
                                                            
                                                                    //System.out.println("ALTRRRRRRRRRRRRROOOOOOOOOOOOO");

                                                                    //arrayWithoutPoint.get(0) = variabile (se c'�), oppure direttamente funzione
                                                                    String args_con_cancelletto_dentro_parentesi = UtilsToSymTable.replaceCharInsideParents(lastParameters,'.');
                                                                    ArrayList<String> arrayWithoutPoint = UtilsToSymTable.tokenParameters(args_con_cancelletto_dentro_parentesi,".");
                                                                    
                                                                    //array.get(0) = nome funzione invocata (al 100%)
                                                                    //array.get(1) = lista dei paramentri passati alla funzione (potrebbe non esistere, se non passo nulla)
                                                                    ArrayList<String> array=UtilsToSymTable.tokenParameters(arrayWithoutPoint.get(arrayWithoutPoint.size()-1),"()");
                                                                    
                                                                    int numFunctionParam = 0;
                                                                    if(array.size()>1){
                                                                            ArrayList<String> params = UtilsToSymTable.tokenParameters(array.get(1),",");
                                                                            numFunctionParam = params.size();
                                                                    }
                                                                    
                                                                    String className2 = new String();
                                                                    //vedo se arrayWithoutPoint.get(0) � una variabile
                                                                    boolean isAVariable = UtilsToSymTable.isExist(arrayWithoutPoint.get(0),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                    //System.out.println("UtilsToSymTable.isExist");
                                                                    if(isAVariable==true){
                                                                            className2 = UtilsToSymTable.getVariableType(arrayWithoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
                                                                    }else{
                                                                            className2 = "DefaultClass";
                                                                    }
                                                                    
                                                                    boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),className2, getIndentation(),parser.getSymbolTable());
                                                                    
                                                                    if(funcOK){
                                                                    		if(UtilsToSymTable.functionHasReturn(array.get(0),String.valueOf(numFunctionParam),className2, getIndentation(), parser.getSymbolTable())){
                                                                    			boolean isOKOK = true;
                                                                    			if(array.size()>1){
                                                                    				isOKOK = UtilsToSymTable.isCorrectListOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
                                                                    			}
                                                                    			
                                                                    			if(isOKOK){
	                                                                    			//System.out.println("funcOK____ TRUE");
		                                                                            boolean flag = UtilsToSymTable.isExist(parameters.get(i),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
		                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
		                                                                            		sb.append(tab);
		                                                                                    if(flag==false)
		                                                                                            sb.append("Object ");
		                                                                                    sb.append(parameters.get(i));
		                                                                            }else{
		                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
		                                                                                    sb.append(tab);
		                                                                                    sb.append(parameterSX);
		                                                                            }
		                                                                            
		                                                                            sb.append(" = ");
		                                                                            
		                                                                            if(className2.equals("DefaultClass")){
	                                                                                	sb.append("DefaultClass."+array.get(0));
	                                                                                	sb.append("(");
	                                                                                	String args = "";
	                                                                                	if(array.size()>1){
	                                                                                		args = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	                                                                                	}
	                                                                                	sb.append(args);
	                                                                                	sb.append(")");
	                                                                                	sb.append(";\n");
	                                                                                }
	                                                                                else{
	                                                                                    sb.append("(("+className2+")"+arrayWithoutPoint.get(0)+")."+array.get(0));
	                                                                                    sb.append("(");
	                                                                                	String args = "";
	                                                                                	if(array.size()>1){
	                                                                                		args = UtilsToSymTable.getStringBuilderOfParametersInsideFunction(array.get(1),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
	                                                                                	}
	                                                                                	sb.append(args);
	                                                                                	sb.append(")");
	                                                                                	sb.append(";\n");
	                                                                                }
		                                                                                                            
		                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
		                                                                                    SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
		                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i),symbol);
		                                                                            }else{
		                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
		                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
		                                                                                    SymbolType symbol=new SymbolType(parameters.get(i),"Object",null,null,null,getIndentation(),null);
		                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable,symbol);
		                                                                            }
                                                                    			}
                                                                    		}else{
                                                                    			sb.append(tab+"//ERROR into Assignament - The method invocated has not return value\n");
                                                                    		}
                                                                            
                                                                    }else{
                                                                    
                                                                            //conosciamo gia' il tipo definitivo -> e NON � String
                                                                            if(splitStringBuilder.get(0).equals("NOTHING-CERTAIN")){
                                                                                    //StringBuilder sb6 = getStringBuilderAssignament(typeLastParameters,lastParameters,parameters.get(i),getIndentation());
                                                                            		StringBuilder sb6 = getStringBuilderAssignament(typeLastParameters,parameters_with_self.get(parameters_with_self.size()-1),parameters_with_self.get(i),getIndentation());
                                                                            		sb.append(tab);
                                                                            		sb.append(sb6.toString());
                                                                                    parser.symTable.putSymbol(getIndentation(),parameters.get(i), new SymbolType(parameters.get(i),typeLastParameters,lastParameters,null,null,getIndentation(),null));
                                                                            }else{
                                                                                    //qui splitStringBuilder.get(0).equals("OBJECT-ASSIGNMENT")
                                                                                    String parameterSX = "(("+splitStringBuilder.get(3)+")"+splitStringBuilder.get(1)+")."+splitStringBuilder.get(2);
                                                                                    sb.append(tab);
                                                                                    sb.append(parameterSX);
                                                                                    //sb.append(getDXAssignament(typeLastParameters,lastParameters));
                                                                                    sb.append(getDXAssignament(typeLastParameters,parameters_with_self.get(parameters_with_self.size()-1)));
                                                                                    String newNameVariable = parameters.get(i)+"#"+splitStringBuilder.get(3);
                                                                                    parser.symTable.putSymbol(getIndentation(),newNameVariable, new SymbolType(parameters.get(i),typeLastParameters,lastParameters,null,null,getIndentation(),null));
                                                                            }
                                                                    
                                                                    }//fine else if(funcOK)

                                                            }
                                                            
                                                    }
                                                    
                                                    
                                            }
                                    	}//fine else che indica che non è una LEN FUNCTION
                                        
                                        }
                                    
                                    }else{
                                            //if sb2==null -> ERROR!
                                            sb.append(tab+"//ERROR IN VARIABLE DEFINITION: ultimo\n");
                                    }
                            
                            }

                    }
                    
                    RESULT = sb.toString();
                    
                    :}
;

augassign		::= PLUSEQ:op 
					{: 
						RESULT=op;
					:}
					| MINUSEQ:op 
					{: 
						RESULT=op;
					:} 
					| MULTEQ:op 
					{: 
						RESULT=op;
					:} 
					| DIVEQ:op 
					{: 
						RESULT=op;
					:} 
					| MODEQ:op 
					{: 
						RESULT=op;
					:} 
					| ANDEQ:op 
					{: 
						RESULT=op;
					:} 
					| OREQ:op 
					{: 
						RESULT=op;
					:} 
					| EXPEQ:op 
					{: 
						RESULT=op;
					:} 
					| RSEQ:op 
					{: 
						RESULT=op;
					:} 
					| LSEQ:op 
					{: 
						RESULT=op;
					:}
;


print_stmt				::= PRINT 
							{: 	
								String tab=" ";
								for(int i=0; i<getIndentation(); i++){
									tab+="\t";
								}
								RESULT= tab+"System.out.println(\"\");\n";
							:} 
							| PRINT testlist:t 
							{: 
								String tab=" ";
								for(int i=0; i<getIndentation(); i++){
									tab+="\t";
								}
							    RESULT = tab + Print_stmt.print_stmt(t.toString(), getIndentation(), parser.getSymbolTable(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
							:}
							| PRINT testlist:t COMMA 
							{:
								String tab=" ";
								for(int i=0; i<getIndentation(); i++){
									tab+="\t";
								}
								RESULT = tab+ Print_stmt.print_stmt(t.toString(), getIndentation(), parser.getSymbolTable(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
							:}
							| PRINT RSHIFT testlist:t 
							{: 
								String tab=" ";
								for(int i=0; i<getIndentation(); i++){
									tab+="\t";
								}
							    String message="PRINT: CANNOT EXECUTE THIS INSTRUCTION\n"; 
							    semanticAlert(message);
							    RESULT= tab+"//ERROR ON PRINT: AUTO GENERATE COMMENT\n";
							:}
;



//GESTIONE RANGE
//Se è necessario iterare su una successione di numeri viene in aiuto la funzione built-in range(), 
//che genera liste contenenti progressioni aritmetiche, ad esempio:
//>>> range(10)
//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
//>>> range(5, 10)
//[5, 6, 7, 8, 9]
//>>> range(0, 10, 3)
//[0, 3, 6, 9]
range_stmt				::= RANGE LPAREN expr:e1 RPAREN 
							{: 
								
								StringBuilder rangeResult = new StringBuilder();
								
								String type = CheckType.check(e1.toString());
								if(type.equals("Integer")){
									rangeResult.append("0#");
									rangeResult.append(e1.toString());
								}else if(type.equals("String")){
									//devo verificare che si tratta di una funzione
									//ma noi gestiamo solo il caso sia una len(...)
									String len = isLEN(e1.toString(),getIndentation());
									if(len!=null){
										//è len
										rangeResult.append("0#");
										rangeResult.append(len);
									}else
										rangeResult.append("//ERROR - range function not defined");
								}

								RESULT = rangeResult.toString();
								
							:}
							| RANGE LPAREN expr:e1 COMMA expr:e2 RPAREN 
							{: 
								
								
								StringBuilder rangeResult = new StringBuilder();
								
								String type1 = CheckType.check(e1.toString());
								String type2 = CheckType.check(e2.toString());
								
								if(type1.equals("Integer")){
									rangeResult.append(e1.toString()+"#");
								}else if(type1.equals("String")){
									String len = isLEN(e1.toString(),getIndentation());
									if(len!=null)
										rangeResult.append(len+"#");
									else
										rangeResult.append("//ERROR - range function not defined");
								}
								
								
								if(type2.equals("Integer")){
									rangeResult.append(e2.toString());
								}else if(type2.equals("String")){
									String len = isLEN(e2.toString(),getIndentation());
									if(len!=null)
										rangeResult.append(len);
									else
										rangeResult.append("//ERROR - range function not defined");
								}

								RESULT = rangeResult.toString();
							:}
							| RANGE LPAREN expr:e1 COMMA expr:e2 COMMA expr:e3 RPAREN 
							{: 
								
								
								StringBuilder rangeResult = new StringBuilder();
								
								String type1 = CheckType.check(e1.toString());
								String type2 = CheckType.check(e2.toString());
								String type3 = CheckType.check(e3.toString());
								
								if(type1.equals("Integer")){
									rangeResult.append(e1.toString()+"#");
								}else if(type1.equals("String")){
									String len = isLEN(e1.toString(),getIndentation());
									if(len!=null)
										rangeResult.append(len+"#");
									else
										rangeResult.append("//ERROR - range function not defined");
								}
								
								
								if(type2.equals("Integer")){
									rangeResult.append(e2.toString()+"#");
								}else if(type2.equals("String")){
									String len = isLEN(e2.toString(),getIndentation());
									if(len!=null)
										rangeResult.append(len+"#");
									else
										rangeResult.append("//ERROR - range function not defined");
								}
								
								
								if(type3.equals("Integer")){
									rangeResult.append(e3.toString());
								}else if(type3.equals("String")){
									String len = isLEN(e3.toString(),getIndentation());
									if(len!=null)
										rangeResult.append(len);
									else
										rangeResult.append("//ERROR - range function not defined");
								}

								RESULT = rangeResult.toString();
								
							:}
;

del_stmt				::= DEL exprlist:explist 
							{: 
								RESULT="del "+explist;
							:}
;

flow_stmt				::= BREAK 
								{: 
									RESULT="break;\n";
								:}
							| CONTINUE 
								{: 
									RESULT="continue;\n";
								:}
							| return_stmt:r 
								{: 
								
									//CASI:
									//1) x+y+z+.....(tutti dello stesso tipo)
									//2) 3+4+6+1+...(tutte costanti dello stesso tipo)
									//3) chiamata di funzione
									//4)intero*tupla oppure tupla*intero
									//5)tupla+tupla+tupla+.....
									//6)lista+lista
									//7)istanza.attributo......FARE CAST DEL TIPO: return (NomeClasse)istanza.attributo
									//*********************************************************************************
									
									StringBuilder sb=new StringBuilder();
									
									//String returnS=array.get(0);
									String returnS = r.toString().replace("return ", "");
									returnS = returnS.replace(";", "");
									
									
									//Come prima cosa, verifichiamo se sul return c'è l'invocazione di una
									//funzione. Stiamo quindi considerando i seguenti tre casi:
									//1) return istanza.funzione(event param);
									//2) return funzione(paramentri);
									
									//arrayWithoutPoint.get(0) = variabile (se c'è), oppure direttamente funzione
									ArrayList<String> arrayWithoutPoint = UtilsToSymTable.tokenParameters(returnS,".");
									
									//array.get(0) = nome funzione invocata (al 100%)
									//array.get(1) = lista dei paramentri passati alla funzione (potrebbe non esistere, se non passo nulla)
									ArrayList<String> array=UtilsToSymTable.tokenParameters(arrayWithoutPoint.get(arrayWithoutPoint.size()-1),"()");
									
									int numFunctionParam = 0;
									if(array.size()>1){
										ArrayList<String> params = UtilsToSymTable.tokenParameters(array.get(1),",");
										numFunctionParam = params.size();
									}
									
									String className = new String();
									//vedo se arrayWithoutPoint.get(0) è una variabile
									boolean isAVariable = UtilsToSymTable.isExist(arrayWithoutPoint.get(0),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
									//System.out.println("UtilsToSymTable.isExist");
									if(isAVariable==true){
										className = UtilsToSymTable.getVariableType(arrayWithoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
									}else{
										className = "DefaultClass";
									}
									
									boolean funcOK = UtilsToSymTable.isCorrectFunctionInvocation(array.get(0),String.valueOf(numFunctionParam),className, getIndentation(),parser.getSymbolTable());
									//System.out.println("UtilsToSymTable.isCorrectFunctionInvocation -> " +array.get(0)+" - "+String.valueOf(numFunctionParam) +" - "+className);
									if(funcOK){
										if(UtilsToSymTable.functionHasReturn(array.get(0),String.valueOf(numFunctionParam),className, getIndentation(), parser.getSymbolTable())){
											if(arrayWithoutPoint.size()>1)
												sb.append("return (("+className+")"+arrayWithoutPoint.get(0)+")."+arrayWithoutPoint.get(1)+";\n");
											else
												sb.append("return DefaultClass."+returnS+";\n");
	
											SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
											parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
										}else{
											sb.append("//ERROR into Return - The Method invocated has not return value\n");
										}
										
									}
									else{
										//casi:
										//1) funzione che NON esiste -> quindi dare errore
										//2) tutti i possibili tipi di espressioni
										//3) variabile Singola o costante Singola
																			
										ArrayList<String> arrayLP = UtilsToSymTable.tokenParameters(returnS,"+\\-*/\\^&\\|<>=%");

										ArrayList<String> arrayOperator= getOperator(arrayLP, returnS);
					
										String newParameters = returnS.replace("self.","");
					            		ArrayList<String> arrayLP_senza_self = UtilsToSymTable.tokenParameters( newParameters,"+\\-*/\\^&\\|<>=%");
										
										if(arrayOperator==null || arrayOperator.isEmpty()){
										
											//non e' una espressione ma un singolo elemento
											//vedo se e' una variabile -> e se esiste
											//in caso positivo, inserisco "return" nella symTable
											
											String type = CheckType.check(returnS.replace("self.",""));
		
											if(type.equals("Object")){
												boolean flag_s = UtilsToSymTable.isExist(returnS.replace("self.",""),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
												
												if(flag_s==true){
													sb.append("return "+returnS+";\n");
													SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
													parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
												}else{
													sb.append("//ERROR ON RETURN STATEMENT - Variable does't exist\n");
												}
												
											}else if(type.equals("String")){
												//per gestire l'invocazione di funzioni che NON esistono:
												//per gestire oggettoClasse.attributo
												//per gestire Stringhe
																		
												//ArrayList<String> withoutPoint = UtilsToSymTable.tokenParameters(arrayLP.get(0),".");
												ArrayList<String> withoutPoint = UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(0),".");
												if(withoutPoint.size()==2){
													//caso: return p.attr
													//withoutPoint.get(0) = p
													//withoutPoint.get(1) = attr
													//System.out.println("Return - Caso p.attr - singolo elemento");
													//pType sarebbe il nome della classe o null in caso di errore
													String pType = UtilsToSymTable.getVariableType(withoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
													if(pType!=null){
														boolean flag_attr = UtilsToSymTable.isCorrectClassAttributeUsed(withoutPoint.get(1),pType,getIndentation(), parser.getSymbolTable());
														sb.append("return (("+pType+")"+withoutPoint.get(0)+")."+withoutPoint.get(1)+";\n");
														SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
														parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
														
													}else{
														sb.append("//ERROR ON RETURN STATEMENT - Variable dosn't exist\n");
													}
												
												}
												else{
													//array=UtilsToSymTable.tokenParameters(arrayLP.get(0),"()");
													array=UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(0),"()");
													String type_per_string = CheckType.check(array.get(0));
													
													if(type_per_string.equals("Object")){
														//possibilmente è una funzione dentro lo stesso scope o una classe ereditata
														ArrayList<String> array2=UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(0),"();");
                                                        
                                                        int numFunctionParam2 = 0;
                                                        if(array2.size()>1){
                                                                ArrayList<String> params = UtilsToSymTable.tokenParameters(array2.get(1),",");
                                                                numFunctionParam2 = params.size();
                                                        }

														 String className2 = null;
					                                     boolean funcOK2 = false;
					                                     if(parser.ereditClassToFunctionInvocation.size()!=0){
					                 						//UtilsToSymTable.printArrayList(parser.ereditClassToFunctionInvocation, "ereditClassToFunctionInvocation");
					                 						for(int qw=0; qw<parser.ereditClassToFunctionInvocation.size(); qw++){
					                 							funcOK2 = UtilsToSymTable.isCorrectFunctionInvocation(array2.get(0),String.valueOf(numFunctionParam),parser.ereditClassToFunctionInvocation.get(qw), getIndentation(),parser.getSymbolTable());
					                                            if(funcOK2){
					                                            	className2 = parser.ereditClassToFunctionInvocation.get(qw); 
					                                            	//System.out.println("parser.ereditClassToFunctionInvocation.get(qw)" + className2);
					                                            	break;
					                                            }
					                 						}
					                                     }else{
					                                        funcOK2 = UtilsToSymTable.isCorrectFunctionInvocation(array2.get(0),String.valueOf(numFunctionParam),null, getIndentation(),parser.getSymbolTable());
					                                     }

					                                     if(funcOK2){
					                                    	 //System.out.println("TROVATO METODO DENTOR RETURN");
					                                    	 
					                                    	 if(UtilsToSymTable.functionHasReturn(array2.get(0),String.valueOf(numFunctionParam),className2, getIndentation(), parser.getSymbolTable())){
					                                    		sb.append("return "+returnS+";\n");
																SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
																parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
                                                      		}else{
                                                      			sb.append("//ERROR ON RETURN STATEMENT - The method invocated has not return value\n");
                                                      		}
					                                     }else{
					                                    	 sb.append("//ERROR ON RETURN STATEMENT - Function does't exist\n");
					                                     }
														
													}else{
														//System.out.println("Return - Semplice Stringa - singolo elemento");
														sb.append("return "+returnS+";\n");
														SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
														parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
													}
												}
												
											}else if(type.equals("Tupla") || type.equals("GenericList") || type.equals("PDictionary")){
												sb.append("return "+"(new "+type+"(\""+returnS+"\"));\n");
												SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
												parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);

											}else{
												//System.out.println("Return - Tutto il resto - singolo elemento");
												sb.append("return "+returnS+";\n");
												SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
												parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
											}
										}
										else{
											//se sono qui, sicuro devo gestire una espressione											

											StringBuilder sb2 = new StringBuilder();
											
											boolean thereIsIstanceClass = false;
											ArrayList<Integer> positionIstanceClass = new ArrayList<Integer>();
											
											for(int w = 0; w<arrayLP.size(); w++){
												
												String ty = CheckType.check(arrayLP.get(w));
												
												if(ty.equals("Object")){
													String typeOfObject = UtilsToSymTable.getVariableType(arrayLP_senza_self.get(w),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
													
													if(typeOfObject!=null){
														if(!typeOfObject.equals("PDictionary")){
															String value = UtilsToSymTable.getValue(arrayLP_senza_self.get(w),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
															sb2.append(value);
															if(w!=arrayOperator.size()){
																sb2.append(arrayOperator.get(w));
															}
														}else{
															ty="ERROR";
															sb.append("//ERROR IN RETURN STATEMENT - Operation From Dictionary not allowed\n");
															break;
														}
													}else{
														//qui ho typeOfObject == null
														ty="ERROR";
														sb.append("//ERROR IN RETURN STATEMENT - Variable not delcared\n");
														break;
													}
												}else if(ty.equals("String")){
						
													ArrayList<String> withoutPoint = UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(w),".");
													if(withoutPoint.size()==2){
														//caso: return p.attr+7
														//withoutPoint.get(0) = p
														//withoutPoint.get(1) = attr
														
														//pType sarebbe il nome della classe o null in caso di errore
														String pType = UtilsToSymTable.getVariableType(withoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
														if(pType!=null){
															String nameAttr = arrayLP_senza_self.get(w) + "#" + pType;
															String value = UtilsToSymTable.getValue(nameAttr,getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
															thereIsIstanceClass = true;
															positionIstanceClass.add(w);
															
															sb2.append(value);
															if(w!=arrayOperator.size()){
																sb2.append(arrayOperator.get(w));
															} 
															
														}else{
															sb.append("//ERROR ON RETURN STATEMENT - Variable dosn't exist\n");
														}
													}else{
													
														if(arrayLP.get(w).contains("self.")){
															//contiene self
															//System.out.println("contiene self.");
															
															sb2.append(arrayLP_senza_self.get(w));
															if(w!=arrayOperator.size()){
																sb2.append(arrayOperator.get(w));
															}
															
														}else{
															array=UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(w),"()");
															String type_per_string = CheckType.check(array.get(0));
															
															if(type_per_string.equals("Object")){
																sb.append("//ERROR ON RETURN STATEMENT - Function does't exist\n");
															}else{
																sb2.append(arrayLP.get(w));
																if(w!=arrayOperator.size()){
																	sb2.append(arrayOperator.get(w));
																}
															}
														}
													}
					
												}else{
													sb2.append(arrayLP.get(w));
													if(w!=arrayOperator.size()){
														sb2.append(arrayOperator.get(w));
													}
												}
											}//fine for "w"
											
											//System.out.println("-- SB2 --- "+sb2.toString());
											
											if(sb2.toString().contains("[") && sb2.toString().contains("]") && sb2.toString().contains(",")){
												//sicuro GenericList
												sb.append("Object tmp_genericList = new GenericList();\n");
												sb.append("return "+"((GenericList)tmp_genericList).resultOperationsGenericList(\""+sb2.toString()+"\");\n");
												SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
												parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);	
											}else if(sb2.toString().contains("(") && sb2.toString().contains(")") && sb2.toString().contains(",")){
												//sicuro Tupla
												sb.append("Object tmp_Tupla = new Tupla();\n");
												sb.append("return "+"((Tupla)tmp_Tupla).resultOperationsTupla(\""+sb2.toString()+"\");\n");
												SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
												parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
											}else{
												
												String ty_pe=new String();
												ArrayList<String> arrayName = UtilsToSymTable.tokenParameters(sb2.toString(),"+\\-*/\\^&\\|<>=%");
												ArrayList<String> arrayNameOperator= getOperator(arrayName, sb2.toString());
												
												for(int k = 0; k<arrayName.size(); k++){
													//System.out.println("arrayName.get(k) "+arrayName.get(k));
													
													String tmpTYPE = CheckType.check(arrayName.get(k));
													
													//System.out.println("tmpTYPE "+tmpTYPE);
													
													if(tmpTYPE.equals("Object")){
														//System.out.println(" DENTRO OBJECT");
														
														String variableTYPE = UtilsToSymTable.getVariableType(arrayName.get(k),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
														
														//System.out.println("variableTYPE "+variableTYPE);
														if(variableTYPE!=null){
															if(!variableTYPE.equals("Object")){
																if(!ty_pe.equals(variableTYPE) && ty_pe.length()!=0)
																	ty_pe = "ERROR";
																else
																	ty_pe = variableTYPE;
															}
														}
													}else{
														if(!ty_pe.equals(tmpTYPE) && ty_pe.length()!=0)
															ty_pe = "ERROR";
														else
															ty_pe = tmpTYPE;
													}
												}//fine for "q"		
												
												if(ty_pe.equals("ERROR")){
													sb.append("//ERROR IN RETURN STATEMENT - Variable Types are different\n");
												}else{
													if(thereIsIstanceClass==false){
														//System.out.println("alla fine del return: " + returnS + " type_ " + ty_pe);
														sb.append("return ");
														boolean isNegativeNumber = false;
														if( newParameters.charAt(0) == '-'){
															sb.append(newParameters.charAt(0));
															isNegativeNumber = true;
														}
														for(int g=0; g<arrayLP_senza_self.size(); g++){
															sb.append( UtilsToSymTable.getFormattedStringToCastInRETURN(ty_pe,arrayLP.get(g)) );
															if(g!=arrayOperator.size() && isNegativeNumber==false)
																sb.append(arrayOperator.get(g));
															else if(g<arrayOperator.size()-1 && isNegativeNumber==true)
																sb.append(arrayOperator.get(g+1));
														}
														sb.append(";\n");
														SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
														parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
													}else{
														//c'è almeno un p.attr
														//la posizione in cui si trova p.att è data da positionIstanceClass.get(x)
														
														//System.out.println("alla fine del return: ThereIsIstanceClass==true");
														
														sb.append("return ");
														boolean isNegativeNumber = false;
														if( newParameters.charAt(0) == '-'){
															sb.append(newParameters.charAt(0));
															isNegativeNumber = true;
														}
														for(int f=0;f<arrayLP.size();f++){
															boolean isPAttr = false; 
															for(int d=0;d<positionIstanceClass.size();d++){
																if(positionIstanceClass.get(d)==f){
																	isPAttr = true;
																	//devo scrivere -> ((classe)p).attr
																	ArrayList<String> withoutPoint = UtilsToSymTable.tokenParameters(arrayLP_senza_self.get(f),".");
																	String className3 = UtilsToSymTable.getVariableType(withoutPoint.get(0),getIndentation(),parser.getSymbolTable(), parser.ereditClassToFunctionInvocation);
																	sb.append("(("+ty_pe+")(("+className3+")"+withoutPoint.get(0)+")."+withoutPoint.get(1)+")");
																	if(f!=arrayOperator.size() && isNegativeNumber==false)
																		sb.append(arrayOperator.get(f));
																	else if(f<arrayOperator.size()-1 && isNegativeNumber==true)
																		sb.append(arrayOperator.get(f+1));
																}
															}//for per d
															
															if(isPAttr==false){
																sb.append(arrayLP.get(f));
																if(f!=arrayOperator.size() && isNegativeNumber==false)
																	sb.append(arrayOperator.get(f));
																else if(f<arrayOperator.size()-1 && isNegativeNumber==true)
																	sb.append(arrayOperator.get(f+1));
															}
															
														}//fine fo per f
														
														sb.append(";\n");
														
														SymbolType symbolReturn=new SymbolType("return","Object",null,null,null,getIndentation(),null);
														parser.symTable.putSymbol(getIndentation(),"return",symbolReturn);
														
													}
												}
											}
										} //fine else per espressioni
									} //fine else che ci dice che non abbiamo funzioni accanto al return
									 RESULT=sb.toString();
								:}
							| raise_stmt:r 
							{: 
							RESULT = r;
							:}
							| yield_expr:y 
							{: 
							RESULT = y; 
							:}
;

return_stmt				::= RETURN testlist:t {: RESULT = "return " + t.toString()+";"; :}
;

raise_stmt				::= RAISE test:t 
							{:
								semanticAlert("RAISE NOT SUPPORTED YET.");
								RESULT="//RAISE NOT SUPPORTED YET.\n";
							
							:}
							| RAISE test:t1 COMMA test:t2 
							{:
								semanticAlert("RAISE NOT SUPPORTED YET.");
								RESULT="//RAISE NOT SUPPORTED YET.\n";
							
							:}
							| RAISE test:t1 COMMA test:t2 COMMA test:t3 
							{:
								semanticAlert("RAISE NOT SUPPORTED YET.");
								RESULT="//RAISE NOT SUPPORTED YET.\n";
							
							:}
;

import_stmt				::= IMPORT dotted_as_names:d 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dotted_name:d IMPORT MULT 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dotted_name:d IMPORT LPAREN import_as_names:i RPAREN 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dotted_name:d IMPORT import_as_names:i 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dot_rec:d dotted_name:n IMPORT MULT 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dot_rec:d dotted_name:n IMPORT LPAREN import_as_names:i RPAREN 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM dot_rec:d dotted_name:n IMPORT import_as_names:i 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM DOT dot_rec:d IMPORT MULT 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM DOT dot_rec:d IMPORT LPAREN import_as_names:i RPAREN 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
							| FROM DOT dot_rec:d IMPORT import_as_names:i 
							{:
							semanticAlert("IMPORT NOT SUPPORTED YET.");
							RESULT="//IMPORT NOT SUPPORTED YET.\n";
							:}
;

//questa produzione e' legata alla produzione relativa all'importazione di una classe, che non viene gestita....
dotted_as_names			::= dotted_as_names:ds COMMA dotted_as_name:d 
							{:
								semanticAlert("(dotted_as_names production)IMPORT NOT SUPPORTED YET.");
								RESULT="//(dotted_as_names production)IMPORT NOT SUPPORTED YET.\n";
							:}
							| dotted_as_name:d 
							{:
								semanticAlert("(dotted_as_name production)IMPORT NOT SUPPORTED YET.");
								RESULT="//(dotted_as_name production)IMPORT NOT SUPPORTED YET.\n";
							:}
;

dotted_as_name			::= dotted_name:d AS NAME:n {::} | dotted_name:d {::}
;

dotted_name				::= NAME:n DOT dotted_name:d {::} | NAME:n {::}
;

import_as_names			::= import_as_name:i COMMA import_as_names:is {::} | import_as_name:i {::}
;

import_as_name			::= NAME:n1 AS NAME:n2 {::} | NAME:n {::}
;

dot_rec					::= DOT dot_rec:d {:RESULT="."+d;:} | DOT {:RESULT=".";:}
;

global_stmt				::= GLOBAL name_recoursive:n 
							{:
							ArrayList<String> tmp = UtilsToSymTable.tokenParameters(n.toString(),",");
							for(int i =0; i<tmp.size();i++){
								parser.symTable.putSymbol(0,tmp.get(i),new SymbolType(tmp.get(i),"Object",null,null,null,0,"DefaultClass"));
								parser.globVar.add(tmp.get(i));
							}
							RESULT="";
							:}
;

name_recoursive			::= name_recoursive:nr COMMA NAME:n {: RESULT=nr+","+n; :}
							| NAME:n {: RESULT=n; :}
;


exec_stmt				::= EXEC expr:e 
							{:
								semanticAlert("EXEC METHOD NOT SUPPORTED YET.");
								RESULT = "//EXEC METHOD NOT SUPPORTED YET.\n";
							:}
							| EXEC expr IN test
							{:
								semanticAlert("EXEC METHOD NOT SUPPORTED YET.");
								RESULT = "//EXEC METHOD NOT SUPPORTED YET.\n";
							:}
							| EXEC expr IN test COMMA test
							{:
								semanticAlert("EXEC METHOD NOT SUPPORTED YET.");
								RESULT = "//EXEC METHOD NOT SUPPORTED YET.\n";
							:}
;

assert_stmt				::= ASSERT testlist:t 
							{:
								RESULT = "assert "+t.toString()+ ";\n";
							
							:}
							 
							|ASSERT testlist:t COLON testlist:t1 
							
							{:
							
								String t2 = t1.toString().replace("'","\"");
								RESULT = "assert "+t.toString()+": "+t2.toString()+";\n";
							
							:}
;



/* 
*****************   Gestione di tutti i BLOCCHI COMPOSTI.... (if, while, for, etc...)  *******************
*/

compound_stmt	::= if_stmt:if_stmt {: 
							RESULT = if_stmt;
					:} 
					| while_stmt:w 
						{: 

							RESULT = w;
						:} 
						
					| for_stmt:f 	{: 
										RESULT = f;
									:}
									 
					| try_stmt:t 	{: 
									 
										RESULT = t;
									:}
									 
					| with_stmt:w 	{: 
										RESULT=w;
										
									:}
									 
					| funcdef:f 	{: 
									
										RESULT = f;
									:}
									 
					| classdef:c	{: 
									
										RESULT = c;  
									:} 
					| decorated {: :} 
;


/*
Regola -> if_stmt ::= if expression : suite ( elif expression : suite )* [else : suite]
es:
1) if x<0 : [suite]
2) if x<0 : [suite] 
   ELIF x>0: [suite]
3) if x<0 : [suite] 
   ELIF x==7: [suite] 
   ELIF x==9: [suite] 
   ELSE: [suite]
*/
if_stmt		::= IF test:t COLON suite:s 
				{: 
						
					RESULT = If_stmt.if_stmt_1(t.toString(),s.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
						
				:}
				
				| IF test:t COLON suite:s1 ELSE COLON suite:s2
				
				{: 
						
					RESULT = If_stmt.if_stmt_2(t.toString(),s1.toString(),s2.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
				:}
				
				| IF test:t COLON suite:s else_recoursive:else_rec 
					
				{: 
					
					RESULT = If_stmt.if_stmt_3(t.toString(),s.toString(),else_rec.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
												 
				:}
				
				| IF test:t COLON suite:s1 else_recoursive:else_rec ELSE COLON suite:s2 
				
				{: 
						 			
					RESULT = If_stmt.if_stmt_4(t.toString(),s1.toString(),else_rec.toString(),s2.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
												
				:}
				
				| IF test:t error suite:s1 
				
				{: 
					int level = parser.scopeHash.remove(t.toString()); 
					semanticError("INVALID SINTAX DEFINED!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SINTAX! IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SINTAX! IGNORING BODY;\n";
				:}
				
				| IF test:t error suite:s1 else_recoursive:else_rec 
				
				{: 
					int level = parser.scopeHash.remove(t.toString()); 
					semanticError("INVALID SINTAX DEFINED!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SINTAX! IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SINTAX! IGNORING BODY;\n";
				:}
				
				| IF test:t error suite:s1 else_recoursive:else_rec ELSE COLON suite:s2 
				{: 
					int level = parser.scopeHash.remove(t.toString()); 
					semanticError("INVALID SINTAX DEFINED!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SINTAX! IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SINTAX! IGNORING BODY;\n";
				:}
				| IF test:t COLON suite:s1 ELSE error suite:s2 
				{: 
					int level = parser.scopeHash.remove(t.toString()); 
					semanticError("INVALID SINTAX DEFINED!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SINTAX! IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SINTAX! IGNORING BODY;\n";
				:}
;


else_recoursive		::= ELIF test:t COLON suite:s 
						
						{: 
							
							RESULT = If_stmt.if_stmt_elif(t.toString(),s.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
							
						:}
							
						| else_recoursive:else_rec ELIF test:t COLON suite:s  
						
						{: 
						
							RESULT = If_stmt.if_stmt_elif_2(t.toString(),s.toString(),else_rec.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
						
						:}
						
						| ELIF test:t error suite:s 
						
						{: 
							int level = parser.scopeHash.remove(t.toString()); 
							semanticError("INVALID CONDITION DEFINED!");
							if(level==0){
	                    		parser.arrayMain.add("//INVALID SYNTAX! ELSE WITHOUT COLON: IGNORING BODY;\n");
		                    	RESULT = "";
	                    	}
							else
								RESULT="//INVALID SYNTAX! ELSE WITHOUT COLON: IGNORING BODY;\n";
						:}
;



//GESTIONE WHILE
while_stmt	::= WHILE test:t COLON suite:s 
				
				{: 
					RESULT = While_stmt.while_stmt_1(t.toString(),s.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
										
				:}
				
				| WHILE test:t COLON suite:s1 ELSE COLON suite:s2 
				
				{: 
					RESULT = While_stmt.while_stmt_2(t.toString(),s1.toString(),s2.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
				:}
				
				| WHILE test:t error:e suite:s 
				
				{: 
					int level = parser.scopeHash.remove(t.toString()); 
					semanticError("INVALID CONDITION DEFINED!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SYNTAX IN WHILE: IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SYNTAX IN WHILE: IGNORING BODY;\n";
				:}
;


//GESTIONE FOR
for_stmt	::= FOR exprlist:e IN testlist:t COLON suite:s 
				
				{: 
				
					RESULT = For_stmt.for_stmt_1(t.toString(),s.toString(),e.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
					
				:}
					
				| FOR exprlist:e IN range_stmt:r COLON suite:s 
				
				{: 
					
					RESULT = For_stmt.for_stmt_2(s.toString(),r.toString(),e.toString(),parser.getSymbolTable(),parser.getScopeHash(),parser.arrayMain, parser.ereditClassToFunctionInvocation);
					
				:}
				
				| FOR exprlist:e IN testlist error suite:s 
				
				{: 
					int level = parser.scopeHash.remove(e.toString()); 
					semanticError("INVALID SYNTAX IN FOR: IGNORING BODY!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SYNTAX IN FOR: IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SYNTAX IN FOR: IGNORING BODY;\n"; 
				
				:}
				
				| FOR exprlist:e IN range_stmt:r error suite:s 
				{: 
					int level = parser.scopeHash.remove(e.toString()); 
					semanticError("INVALID SYNTAX IN FOR: IGNORING BODY!");
					if(level==0){
	            		parser.arrayMain.add("//INVALID SYNTAX IN FOR: IGNORING BODY;\n");
	                	RESULT = "";
	            	}
					else
						RESULT="//INVALID SYNTAX IN FOR: IGNORING BODY;\n";  
				:}
;


//GESTIONE TRY
try_stmt	::= TRY COLON suite:s1 FINALLY COLON suite:s2 
				{:
					
					if(getIndentation()==0){
						parser.arrayMain.add( "try{"+"\n"+s1.toString()+"\n}\n"+"catch(Exception e){\n e.printStackTrace();\n}\n"+"finally{\n"+s2.toString()+"\n}\n" );
						RESULT = "";
					}
					else
						RESULT="try{"+"\n"+s1.toString()+"\n}\n"+"catch(Exception e){\n e.printStackTrace();\n}\n"+"finally{\n"+s2.toString()+"\n}\n";

				:}
				| TRY COLON suite:s1 except_clause_recoursive:excrec 
				{:
				
					if(getIndentation()==0){
						parser.arrayMain.add( "try{"+"\n"+s1.toString()+"\n}\n"+excrec.toString() );
						RESULT = "";
					}
					else
						RESULT="try{"+"\n"+s1.toString()+"\n}\n"+excrec.toString();
				
				:}
				
				| TRY COLON suite:s1 except_clause_recoursive:excrec ELSE COLON suite:s2 
				
				{:
					if(getIndentation()==0){
						parser.arrayMain.add( "try{"+"\n"+s1.toString()+"\n"+s2.toString()+"\n}\n"+excrec.toString() );
						RESULT = "";
					}
					else
						RESULT="try{"+"\n"+s1.toString()+"\n"+s2.toString()+"\n}\n"+excrec.toString();
				
				:}
				
				| TRY COLON suite:s1 except_clause_recoursive:excrec FINALLY COLON suite:s2 
				
				{:
					
					if(getIndentation()==0){
						parser.arrayMain.add( "try{"+"\n"+s1.toString()+"\n}\n"+excrec.toString()+"\n"+"finally{\n"+s2.toString()+"\n}\n" );
						RESULT = "";
					}
					else
						RESULT="try{"+"\n"+s1.toString()+"\n}\n"+excrec.toString()+"\n"+"finally{\n"+s2.toString()+"\n}\n";

				:}
				
				| TRY COLON suite:s1 except_clause_recoursive:excrec ELSE COLON suite:s2 FINALLY COLON suite:s3 
				
				{:
					if(getIndentation()==0){
						parser.arrayMain.add( "try{"+"\n"+s1.toString()+"\n"+s2.toString()+"\n}\n"+excrec.toString()+"\n"+"finally{\n"+s3.toString()+"\n}\n" );
						RESULT = "";
					}
					else
						RESULT="try{"+"\n"+s1.toString()+"\n"+s2.toString()+"\n}\n"+excrec.toString()+"\n"+"finally{\n"+s3.toString()+"\n}\n";
				:}
;

except_clause_recoursive ::= except_clause:ec COLON suite:s 
							{:
								RESULT=ec.toString()+"{"+s.toString()+"}";
							:} 
							| except_clause_recoursive:ecrec except_clause:ec COLON suite:s 
							{: 
								RESULT="catch(IOException e)"+"{"+s.toString()+"}";
							:}
;

except_clause			::= EXCEPT 
						{:
							RESULT="catch(Exception e)";
						:}
						| EXCEPT test:t 
						{:
							//Mi aspetto una forma del tipo: ValueError:
							if(t.toString().equals("IOError"))
								RESULT="catch(IOException e)";
							else RESULT="catch(Exception e)";
						:}
						
						| EXCEPT test:t AS test:t2 
						{: 
							if(t.toString().equals("IOError"))
								RESULT="catch(IOException "+t2.toString()+")";
							else
								RESULT="catch(Exception "+t2.toString()+")";
						:}
						
						| EXCEPT test:t1 COMMA test:t2 
						{: 
							RESULT="catch(Exception e)";
						:}
;

/*
Gestione WITH:
A cosa serve? E' molto utile perché ti permette di lavorare su un oggetto e di assicurarsi la 
sua "finalizzazione" (nel caso dei file, il file viene aperto con la open, ma viene chiuso automaticamente 
appena si esce da blocco with; nel caso dei lock, invece, vengono acquisiti per poi essere rilasciati).
*/
with_stmt				::= WITH with_item:w with_item_recoursive:wr COLON suite:s 
							{: 
								semanticAlert("WITH CONSTRUCT NOT SUPPORTED.");
								RESULT = "// WITH CONSTRUCT NOT SUPPORTED.\n"; 
							:}
;

with_item				::= test:t 
							{:
								RESULT="";
							:} 
							
							| test:t AS expr:e 
							{:
								RESULT="";
							:}
;

with_item_recoursive	::= COMMA with_item:w 
							{:
								RESULT="";
							:}
							
							|with_item_recoursive:wr COMMA with_item:w 
							{:
								RESULT="";
							:}
;

suite	::= simple_stmt:simple 
				{: 
					//parser.scopeHash.put(simple.toString(),getIndentation());
					RESULT = simple;
				:}
			| NEWLINE INDENT stmt_rec:s DEDENT
				{: 
					RESULT = s;
				:}
;

stmt_rec	::= stmt_rec:sr stmt:s 
					{:
						RESULT = sr.toString()+s.toString();
					:}
				| stmt:s 
					{:
						RESULT = s.toString();
					:} 
;

/*
--------------------------------------- GESTIONE ESPRESSIONI ------------------------------------ 
*/

assign_recoursive		::= ASSIGN testlist:t assign_recoursive:ass_rec
								{:
									RESULT = "="+t+ass_rec;
								:} 
							| ASSIGN testlist:t {:
								RESULT = "="+t;
							:} 
; 


test					::= comparison:c 
								{: 
									parser.scopeHash.put(c.toString(),getIndentation());
									RESULT = c;
								:} 
							| lambdef:l 
								{: 	
									RESULT = l.toString();
								:}
;



comparison				::= comparison:c binop:b expr:e  
								{: 
									//System.out.println("comparison:c binop:b expr:e  ");
									RESULT = c.toString() + b.toString() + e.toString();
								:}
							| expr:e 
								{: 
									//System.out.println("comparison -> expr:e  "+e.toString());
									RESULT = e;
								:}
;

//binop = sono tutti i possibili operatori.... 
binop 					::= PLUS:p {:RESULT = p;:} 
							| MINUS:m {:RESULT = m;:}
							| MULT:m {:RESULT = m;:}
							| DIVIDE:d {:RESULT = d;:}
							| EXPON:ex {:RESULT = ex;:}
							| MOD:m {:RESULT = m;:}
							| IS:is {:RESULT = "==";:}
							| IN:in {:RESULT = in;:}
							| IS NOT:isnot {: RESULT = "!="; :}
							| NOT IN:notin {:RESULT = notin;:}
							| LSHIFT:lshift {:RESULT = lshift;:}
							| RSHIFT: rshift{:RESULT = rshift;:}
		 					| MINOR:min {:RESULT = min;:}
		 					| MINEQ:mineq {:RESULT = mineq;:}
		 					| MAIOR:mag {:RESULT = mag;:}
		 					| MAIEQ:maieq {:RESULT = maieq;:}
		 					| EQ:eq {:RESULT = eq;:}
		 					| NEQ {:RESULT = "!=";:}
		 					| AND {:RESULT = " && ";:}
		 					| OR {:RESULT = " || ";:}
		 					| MULTMULT {:RESULT = "^";:}
		 					| NOT:not {: RESULT = "!"; :}
		 					| PIPE:p {:RESULT=" || ";:}
		 					| ECOM:ec {:RESULT=" && ";:}
		 					| DIVDIV {:RESULT = "/";:}
;

expr					::= atom:a 
								{: 
									RESULT = a;
								:} 
							| atom:a trailer:t 
								{:  
									//System.out.println("SONO ENTRATO:"+a+t);
									RESULT=a.toString()+t.toString();
									
								:}
;

atom					::= NAME:n 
								{: 
									RESULT = n;
								:} 
							| number:n 
								{: 
									RESULT = n;
								:} 
							| STRING:s 
								{: 
									RESULT = s;
								:}
							| unop:u  atom:a  
								{:
									RESULT = u.toString() + a.toString();
								:}
							| LPAREN RPAREN 
								{:
									RESULT = "()";
								:}
							| LCURLY RCURLY 
								{:
									RESULT = "{}";
								:}
							| LPAREN yield_expr:y RPAREN 
								{:
									RESULT = y;							
								:}
							| LPAREN testlist_comp:t RPAREN 
								{:
									RESULT = "("+t.toString()+")";
								:}
							| LBRACK testlist:t RBRACK 
								{:
									RESULT = "["+t.toString()+"]";
								:}
							| LBRACK listmaker:l RBRACK 
								{:
									RESULT = "["+l.toString()+"]";
								:}
							| LCURLY dictorsetmaker:d RCURLY 
								{:
									RESULT = "{"+d.toString()+"}";
								:}
							| LPAREN error
							
							{:
								//semanticError("Error: Invalid syntax.");
								RESULT = "(";
							
							:}
							| LCURLY error
							
							{:
								semanticError("Error: Invalid syntax.");
								RESULT = "{";
							
							:} 
							| LPAREN yield_expr:y error
							{:
								semanticAlert("Error: Invalid syntax: 'yeld' not supported yet.");
								RESULT = "//'yeld' not supported yet.\n";
							
							:} 
							| LPAREN testlist_comp:t error
							{:
								semanticError("Error: Invalid syntax -> Expected ')'.");
								RESULT = "("+t.toString();
							
							:} 
							| LBRACK error
							{:
								semanticError("Error: Invalid syntax -> Expected ']'.");
								RESULT = "[";
							
							:} 
							| LCURLY dictorsetmaker:d error
							{:
								semanticError("Error: Invalid syntax.");
								RESULT = "{";
							:} 
;

//SEGNI: - | + | ~ 
unop					::= MINUS:m 
								{:
									RESULT=m;
								:} 
							| PLUS:p 
								{:
									RESULT=p;
								:} 
							| TILDE:t 
								{:
									RESULT=t;
								:}
;


number					::= FLOAT:f {:RESULT = Float.parseFloat(f.toString());:} 
							| IMAGNUM:i {:RESULT = i.toString();:}
							| LONGINT:li {:RESULT = li.toString();:} 
							| DECIMAL:d {:RESULT = Integer.parseInt(d.toString());:}
							| HEX:h	{:RESULT = h.toString();:} 
							| OCT:o {:RESULT = o.toString();:}
							| BIN:b {:RESULT = b.toString();:}
;

yield_expr				::= YIELD 
								{:
									String message="YIELD: THIS OPERATION IN Java is different\n"; 
									semanticAlert(message);
									RESULT = "//ERROR ON YIELD: AUTO GENERATE COMMENT\n";
								:}
							| YIELD testlist
								{:
									String message="YIELD: OPERAZIONE NON PERMESSA IN JAVA\n"; 
									semanticAlert(message);
									RESULT = "//ERROR ON YIELD: AUTO GENERATE COMMENT\n";
								:}
;

listmaker				::= test:t list_for:l 
								{: 
									//System.out.println(" ---------> LISTA! <------"); 
									RESULT = "";
								:} 
							| 
								{: 
									RESULT = "";
								:} 
;

dictorsetmaker			::= test:t1 COLON test:t2 
							{: 
								RESULT = t1.toString() + ":" + t2.toString();
							:}
						| dictorsetmaker:dic COMMA test:t1 COLON test:t2 
							{: 
								RESULT = dic.toString() + ","+ t1.toString()+ ":" + t2.toString();
							:}
;

testlist_comp			::= testlist:tlist 
							{:
								RESULT = tlist.toString();
							:}
						| test:t list_for:l 
							{:
								//System.out.println("test:t list_for:l ---- ");
								//DA FARE
							:} 
;

testlist		::= testlist:tl COMMA test:t 
						{: 
							boolean isAclass = UtilsToSymTable.isExistClass(t.toString(),0, parser.getSymbolTable());
							if(isAclass)
								parser.ereditClassToFunctionInvocation.add(t.toString());
							RESULT =tl.toString()+","+t.toString();
						:}
					| test:t 
						{: 
							boolean isAclass = UtilsToSymTable.isExistClass(t.toString(),0, parser.getSymbolTable());
							if(isAclass)
								parser.ereditClassToFunctionInvocation.add(t.toString());
							//System.out.println("I'M A TESTLIST: "+t.toString());
							RESULT = t;
						:}
;

exprlist				::= expr:e 
								{:
									int level = getIndentation();
									//System.out.println("I'M A exprlist: "+ level);
									parser.scopeHash.put(e.toString(),level);
									parser.symTable.putSymbol(level,e.toString(), new SymbolType(e.toString(),"Object","0",null,null,level,null));
									RESULT = e;
								:}
							|exprlist:explist COMMA expr:e 
								{:  
									//*******************DA RIVEDERE:PROVVISORIO***********
									//System.out.println("I'M A exprlist con virgola: "+ getIndentation());
									parser.scopeHash.put(e.toString(),getIndentation());
									parser.symTable.putSymbol(getIndentation(),e.toString(), new SymbolType(e.toString(),"Object","0",null,null,getIndentation(),null));
									RESULT=explist+"+"+e;
								:}
;

lambdef					::= LAMBDA COLON test:t 
						{:
							String message="THIS INSTRUCTION CAN'T CONVERT FROM PYTHON TO JAVA";
							semanticAlert( message);
							RESULT="//AUTO GENERATE COMMENT: ERROR FROM lambdef\n";	
						:} 
							| LAMBDA varargslist:v COLON test:t 
						{:
							String message="THIS INSTRUCTION CAN'T CONVERT FROM PYTHON TO JAVA";
							semanticAlert( message);
							RESULT="//AUTO GENERATE COMMENT: ERROR FROM lambdef\n";
						:}
;

trailer					::= LPAREN RPAREN 
								{:
									RESULT = "();";
								:}
							| LPAREN arglist:a RPAREN 
								{:
									//System.out.println("STAMPO"+a);
									RESULT = "("+a.toString()+")";
								:}
							| LBRACK RBRACK 
								{:
									RESULT = "[]";
								:}
							| LBRACK subscriptlist:s RBRACK 
								{:
									RESULT = "[" + s.toString() + "]";
								:}
							| DOT NAME:n 
								{:
									RESULT = "."+n.toString();
								:}
							| DOT NAME:n LPAREN RPAREN
								{:
									RESULT = "."+n.toString()+"()";
								:}
							| DOT NAME:n LPAREN positional_arguments:a RPAREN
								{:
									RESULT = "."+n.toString()+"("+a.toString()+")";
								:}
							| DOT NAME:n LBRACK RBRACK
							{:
								RESULT = "."+n.toString()+"[]";
							:}
							| DOT NAME:n LBRACK expr:a RBRACK
							{:
								RESULT = "."+n.toString()+"["+a.toString()+"]";
							:}
								
;
							
subscriptlist			::= subscript:s {:RESULT = s;:} 
							| subscript subscript_rec
;

subscript_rec			::= COMMA subscript 
							| subscript_rec COMMA subscript 
;

subscript				::= TRIDOT {:RESULT="...";:} 
							| test:t {:RESULT = t;:} 
							| COLON {:RESULT=":";:}
							| test:t COLON {:RESULT=t.toString()+":";:}
							| test:t COLON test:t2 {:RESULT=t.toString()+":"+t2.toString();:}
							| test:t COLON test:t2 sliceop:slice {:RESULT=t.toString()+":"+t2.toString()+slice.toString();:}
							| test:t COLON sliceop:slice {:RESULT=t.toString()+":"+slice.toString();:}
							| COLON test:t {:RESULT=":"+t.toString();:}
							| COLON test:t sliceop:slice {:RESULT=":"+t.toString()+slice.toString();:}
							| COLON sliceop:slice {:RESULT=":"+slice.toString();:}
;

sliceop					::= COLON {:RESULT=":";:} 
							| COLON test:t {:RESULT=":"+t.toString();:}
;

classdef				::= CLASS NAME:n COLON suite:s 
							
							{:
								RESULT = Classdef_stmt.classdef_stmt_1(n.toString(),s.toString(),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
							
							:}  
							
							| CLASS NAME:n LPAREN RPAREN COLON suite:s
							
							{:
								RESULT = Classdef_stmt.classdef_stmt_2(n.toString(),s.toString(),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation);
							
							:}  
							
							| CLASS NAME:n LPAREN testlist:t RPAREN COLON suite:s
							
							{:
								RESULT = Classdef_stmt.classdef_stmt_3(n.toString(),s.toString(),t.toString(),getIndentation(), parser.getSymbolTable(),parser.ereditClassToFunctionInvocation, parser.InherSupport, parser.ignore);
							
							:}
;

arglist					::=	argument:a {:RESULT = a;:}
							| argument:a argument_rec:ar {:RESULT = a + ar.toString();:}
							| MULT test
							| MULT test argument_rec
							| MULT test COMMA MULTMULT test
							| MULT test argument_rec MULTMULT test
							| MULTMULT test
;

argument_rec			::= COMMA argument:a {:RESULT = ","+a;:} 
							| COMMA argument:a argument_rec:ar {:RESULT = ","+a+ar;:}
							| COMMA{:RESULT = ",";:}
;

argument				::= test:t {:RESULT = t.toString();:} 
							| test:t comp_for:c {:RESULT = t.toString() + " " +c.toString();:} 
							| test:t1 ASSIGN:assign test:t2 {:RESULT = t1.toString()+assign.toString()+t2.toString();:}
;


// **********************   DA RIVEDERE E SISTEMARE IN BASE A CIÒ CHE JAVA PERMETTE DI FARE ***********


list_iter				::= list_for:l {: RESULT=l.toString(); :} 
							| list_if:l {: RESULT=l.toString(); :}
;

list_for		::= FOR exprlist:e IN testlist:t {: RESULT = "for "+e.toString()+" in "+t.toString(); :} 
					| FOR exprlist:e IN testlist:t list_iter:l {: RESULT = "for "+e.toString()+" in "+t.toString()+l.toString();:}
					| FOR exprlist:e IN range_stmt:r list_iter:l {::}
;

list_if					::= IF test:t {: RESULT="if "+t.toString(); :} 
							| IF test:t list_iter:l  {: RESULT = "if "+t.toString()+l.toString(); :}
;

comp_iter				::= comp_for:l {:RESULT=l.toString();:} 
							| comp_if:l {:RESULT=l.toString();:}
;

comp_for				::= FOR exprlist:e IN test:t {: RESULT = "for "+e.toString()+" in "+t.toString(); :} 
							| FOR exprlist:e IN test:t comp_iter:c {: RESULT = "for "+e.toString()+" in "+t.toString()+c.toString(); :}
;

comp_if					::= IF test:t {: RESULT="if "+t.toString(); :} 
							| IF test:t comp_iter:c {: RESULT = "if "+t.toString()+c.toString(); :}
; 

comment	::= COMMENT:c {: 
		String tab=" ";
		for(int i=0; i<getIndentation(); i++){
			tab+="\t";
		}
		RESULT = tab+c.toString().replace("#","//")+"\n"; 
	:}
;